<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy080080.github.io/</id>
    <title>听故事的人</title>
    <updated>2019-09-11T03:46:47.217Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy080080.github.io/"/>
    <link rel="self" href="https://zy080080.github.io//atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://zy080080.github.io//images/avatar.png</logo>
    <icon>https://zy080080.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 听故事的人</rights>
    <entry>
        <title type="html"><![CDATA[汇编语言相关指令英文全称]]></title>
        <id>https://zy080080.github.io//post/hui-bian-yu-yan-xiang-guan-zhi-ling-ying-wen-quan-cheng</id>
        <link href="https://zy080080.github.io//post/hui-bian-yu-yan-xiang-guan-zhi-ling-ying-wen-quan-cheng">
        </link>
        <updated>2019-09-11T05:41:55.000Z</updated>
        <content type="html"><![CDATA[<p>AH&amp;AL＝AX(accumulator)：累加寄存器<br>
BH&amp;BL＝BX(base)：基址寄存器<br>
CH&amp;CL＝CX(count)：计数寄存器<br>
DH&amp;DL＝DX(data)：数据寄存器<br>
SP（Stack Pointer）：堆栈指针寄存器<br>
BP（Base Pointer）：基址指针寄存器<br>
SI（Source Index）：源变址寄存器<br>
DI（Destination Index）：目的变址寄存器<br>
IP（Instruction Pointer）：指令指针寄存器<br>
CS（Code Segment）代码段寄存器<br>
DS（Data Segment）：数据段寄存器<br>
SS（Stack Segment）：堆栈段寄存器<br>
ES（Extra Segment）：附加段寄存器<br>
OF overflow flag 溢出标志 操作数超出机器能表示的范围表示溢出,溢出时为1.<br>
SF sign Flag 符号标志 记录运算结果的符号,结果负时为1.<br>
ZF zero flag 零标志 运算结果等于0时为1,否则为0.<br>
CF carry flag 进位标志 最高有效位产生进位时为1,否则为0.<br>
AF auxiliary carry flag 辅助进位标志 运算时,第3位向第4位产生进位时为1,否则为0.<br>
PF parity flag 奇偶标志 运算结果操作数位为1的个数为偶数个时为1,否则为0.<br>
DF direcion flag 方向标志 用于串处理.DF=1时,每次操作后使SI和DI减小.DF=0时则增大.<br>
IF interrupt flag 中断标志 IF=1时,允许CPU响应可屏蔽中断,否则关闭中断.<br>
TF trap flag 陷阱标志 用于调试单步操作.</p>
<h3 id="1通用数据传送指令">1.通用数据传送指令</h3>
<p>MOV----&gt; move<br>
MOV dest,src ;dest←src<br>
MOV指令把一个字节或字的操作数从源地址src传送至目的地址dest。</p>
<p>MOVSX----&gt;extended move with sign data<br>
MOVZX----&gt;extended move with zero data<br>
PUSH----&gt;push<br>
POP----&gt;pop<br>
进栈出栈指令<br>
PUSHA----&gt;push all<br>
POPA----&gt;pop all<br>
PUSHAD----&gt;push all data<br>
POPAD----&gt;pop all data<br>
BSWAP----&gt;byte swap<br>
XCHG----&gt;exchange<br>
交换指令用来将源操作数和目的操作数内容交换，操作数可以是字、也可以是字节，可以在通用寄存器与通用寄存器或存储器之间对换数据，但不能在存储器与存储器之间对换数据。<br>
mov ax,1234h ;ax=1234h<br>
mov bx,5678h ;bx=5678h<br>
xchg ax,bx ;ax=5678h，bx=1234h<br>
xchg ah,al ;ax=7856h</p>
<p>CMPXCHG----&gt;compare and change<br>
XADD----&gt;exchange and add</p>
<p>XLAT----&gt;translate<br>
换码指令用于将BX指定的缓冲区中、AL指定的位移处的数据取出赋给AL。</p>
<h3 id="2输入输出端口传送指令">2.输入输出端口传送指令</h3>
<p>IN----&gt;input<br>
OUT----&gt;output</p>
<h3 id="3目的地址传送指令">3.目的地址传送指令</h3>
<p>LEA----&gt;load effective addres<br>
有效地址传送指令<br>
mov bx,0400h<br>
mov si,3ch<br>
lea bx,[bx+si+0f62h] ;BX=139EH<br>
这里BX得到的是主存单元的有效地址，不是物理地址，也不是该单元的内容。<br>
LDS----&gt;load DS<br>
LES----&gt;load ES<br>
LFS----&gt;load FS<br>
LGS----&gt;load GS<br>
LSS----&gt;load SS</p>
<h3 id="4标志传送指令">4.标志传送指令</h3>
<p>LAHF----&gt;load AH from flag<br>
SAHF----&gt;save AH to flag<br>
PUSHF----&gt;push flag<br>
POPF----&gt;pop flag<br>
PUSHD----&gt;push dflag<br>
POPD----&gt;pop dflag</p>
<h2 id="二-算术运算指令">二、算术运算指令</h2>
<p>ADD----&gt;add<br>
加法指令 mov al,0fbh ;al=0fbh<br>
add al,07h ;al=02h<br>
ADC----&gt;add with carry<br>
INC----&gt;increase 1<br>
AAA----&gt;ascii add with adjust<br>
DAA----&gt;decimal add with adjust<br>
SUB----&gt;substract<br>
SBB----&gt;substract with borrow<br>
DEC----&gt;decrease 1<br>
NEC----&gt;negative<br>
CMP----&gt;compare<br>
AAS----&gt;ascii adjust on substract<br>
DAS----&gt;decimal adjust on substract<br>
MUL----&gt;multiplication<br>
IMUL----&gt;integer multiplication<br>
AAM----&gt;ascii adjust on multiplication<br>
DIV----&gt;divide<br>
IDIV----&gt;integer divide<br>
AAD----&gt;ascii adjust on divide<br>
CBW----&gt;change byte to word<br>
CWD----&gt;change word to double word<br>
CWDE----&gt;change word to double word with sign to EAX<br>
CDQ----&gt;change double word to quadrate word</p>
<h2 id="三-逻辑运算指令">三、逻辑运算指令</h2>
<p>AND----&gt;and<br>
or----&gt;or<br>
XOR----&gt;xor<br>
NOT----&gt;not<br>
TEST----&gt;test<br>
SHL----&gt;shift left<br>
SAL----&gt;arithmatic shift left<br>
SHR----&gt;shift right<br>
SAR----&gt;arithmatic shift right<br>
ROL----&gt;rotate left<br>
ROR----&gt;rotate right<br>
RCL----&gt;rotate left with carry<br>
RCR----&gt;rotate right with carry</p>
<h2 id="四-串指令">四、串指令</h2>
<p>MOVS----&gt;move string<br>
CMPS----&gt;compare string<br>
SCAS----&gt;scan string<br>
LODS----&gt;load string<br>
STOS----&gt;store string<br>
REP----&gt;repeat<br>
REPE----&gt;repeat when equal<br>
REPZ----&gt;repeat when zero flag<br>
REPNE----&gt;repeat when not equal<br>
REPNZ----&gt;repeat when zero flag<br>
REPC----&gt;repeat when carry flag<br>
REPNC----&gt;repeat when not carry flag</p>
<h2 id="五-程序转移指令">五、程序转移指令</h2>
<p>1&gt;无条件转移指令(长转移)</p>
<p>JMP----&gt;jump<br>
CALL----&gt;call<br>
RET----&gt;return<br>
RETF----&gt;return far</p>
<p>2&gt;条件转移指令(短转移,-128到+127的距离内)</p>
<p>JAE----&gt;jump when above or equal<br>
JNB----&gt;jump when not below<br>
JB----&gt;jump when below<br>
JNAE----&gt;jump when not above or equal<br>
JBE----&gt;jump when below or equal<br>
JNA----&gt;jump when not above<br>
JG----&gt;jump when greater<br>
JNLE----&gt;jump when not less or equal<br>
JGE----&gt;jump when greater or equal<br>
JNL----&gt;jump when not less<br>
JL----&gt;jump when less<br>
JNGE----&gt;jump when not greater or equal<br>
JLE----&gt;jump when less or equal<br>
JNG----&gt;jump when not greater<br>
JE----&gt;jump when equal<br>
JZ----&gt;jump when has zero flag<br>
JNE----&gt;jump when not equal<br>
JNZ----&gt;jump when not has zero flag<br>
JC----&gt;jump when has carry flag<br>
JNC----&gt;jump when not has carry flag<br>
JNO----&gt;jump when not has overflow flag<br>
JNP----&gt;jump when not has parity flag<br>
JPO----&gt;jump when parity flag is odd<br>
JNS----&gt;jump when not has sign flag<br>
JO----&gt;jump when has overflow flag<br>
JP----&gt;jump when has parity flag<br>
JPE----&gt;jump when parity flag is even<br>
JS----&gt;jump when has sign flag</p>
<p>3&gt;循环控制指令(短转移)</p>
<p>LOOP----&gt;loop<br>
LOOPE----&gt;loop equal<br>
LOOPZ----&gt;loop zero<br>
LOOPNE----&gt;loop not equal<br>
LOOPNZ----&gt;loop not zero<br>
JCXZ----&gt;jump when CX is zero<br>
JECXZ----&gt;jump when ECX is zero</p>
<p>4&gt;中断指令</p>
<p>INT----&gt;interrupt<br>
INTO----&gt;overflow interrupt<br>
IRET----&gt;interrupt return</p>
<p>5&gt;处理器控制指令</p>
<p>HLT----&gt;halt<br>
WAIT----&gt;wait<br>
ESC----&gt;escape<br>
LOCK----&gt;lock<br>
NOP----&gt;no operation<br>
STC----&gt;set carry<br>
CLC----&gt;clear carry<br>
CMC----&gt;carry make change<br>
STD----&gt;set direction<br>
CLD----&gt;clear direction<br>
STI----&gt;set interrupt<br>
CLI----&gt;clear interrupt</p>
<h2 id="六-伪指令">六、伪指令</h2>
<p>DW----&gt;definw word<br>
PROC----&gt;procedure<br>
ENDP----&gt;end of procedure<br>
SEGMENT----&gt;segment<br>
ASSUME----&gt;assume<br>
ENDS----&gt;end segment<br>
END----&gt;end</p>
<h1 id="汇编指令中文释义">汇编指令中文释义</h1>
<h2 id="1数据传输指令">1.数据传输指令</h2>
<p>它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.</p>
<ol>
<li>通用数据传送指令.<br>
MOV 传送字或字节.<br>
MOVSX 先符号扩展,再传送.<br>
MOVZX 先零扩展,再传送.<br>
PUSH 把字压入堆栈.<br>
POP 把字弹出堆栈.<br>
PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.<br>
POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.<br>
PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.<br>
POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.<br>
BSWAP 交换32位寄存器里字节的顺序<br>
XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)<br>
CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX )<br>
XADD 先交换再累加.( 结果在第一个操作数里 )<br>
XLAT 字节查表转换.<br>
── BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即<br>
0-FFH); 返回 AL 为查表结果. ( [BX+AL]-&gt;AL )</li>
<li>输入输出端口传送指令.<br>
IN I/O端口输入. ( 语法: IN 累加器, {端口号│DX} )<br>
OUT I/O端口输出. ( 语法: OUT {端口号│DX},累加器 )<br>
输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,<br>
其范围是 0-65535.</li>
<li>目的地址传送指令.<br>
LEA 装入有效地址.<br>
例: LEA DX,string ;把偏移地址存到DX.<br>
LDS 传送目标指针,把指针内容装入DS.<br>
例: LDS SI,string ;把段地址:偏移地址存到DS:SI.<br>
LES 传送目标指针,把指针内容装入ES.<br>
例: LES DI,string ;把段地址:偏移地址存到ES:DI.<br>
LFS 传送目标指针,把指针内容装入FS.<br>
例: LFS DI,string ;把段地址:偏移地址存到FS:DI.<br>
LGS 传送目标指针,把指针内容装入GS.<br>
例: LGS DI,string ;把段地址:偏移地址存到GS:DI.<br>
LSS 传送目标指针,把指针内容装入SS.<br>
例: LSS DI,string ;把段地址:偏移地址存到SS:DI.</li>
<li>标志传送指令.<br>
LAHF 标志寄存器传送,把标志装入AH.<br>
SAHF 标志寄存器传送,把AH内容装入标志寄存器.<br>
PUSHF 标志入栈.<br>
POPF 标志出栈.<br>
PUSHD 32位标志入栈.<br>
POPD 32位标志出栈.</li>
</ol>
<h2 id="二-算术运算指令-2">二、算术运算指令</h2>
<p>───────────────────────────────────────<br>
ADD 加法.<br>
ADC 带进位加法.<br>
INC 加 1.<br>
AAA 加法的ASCII码调整.<br>
DAA 加法的十进制调整.<br>
SUB 减法.<br>
SBB 带借位减法.<br>
DEC 减 1.<br>
NEC 求反(以 0 减之).<br>
CMP 比较.(两操作数作减法,仅修改标志位,不回送结果).<br>
AAS 减法的ASCII码调整.<br>
DAS 减法的十进制调整.<br>
MUL 无符号乘法.<br>
IMUL 整数乘法.<br>
以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算),<br>
AAM 乘法的ASCII码调整.<br>
DIV 无符号除法.<br>
IDIV 整数除法.<br>
以上两条,结果回送:<br>
商回送AL,余数回送AH, (字节运算);<br>
或 商回送AX,余数回送DX, (字运算).<br>
AAD 除法的ASCII码调整.<br>
CBW 字节转换为字. (把AL中字节的符号扩展到AH中去)<br>
CWD 字转换为双字. (把AX中的字的符号扩展到DX中去)<br>
CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去)<br>
CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去)</p>
<h2 id="三-逻辑运算指令-2">三、逻辑运算指令</h2>
<p>───────────────────────────────────────<br>
AND 与运算.<br>
or 或运算.<br>
XOR 异或运算.<br>
NOT 取反.<br>
TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果).<br>
SHL 逻辑左移.<br>
SAL 算术左移.(=SHL)<br>
SHR 逻辑右移.<br>
SAR 算术右移.(=SHR) 当值为负时，高位补 1 ；当值为正时，高位补 0<br>
ROL 循环左移.<br>
ROR 循环右移.<br>
RCL 通过进位的循环左移.<br>
RCR 通过进位的循环右移.<br>
以上八种移位指令,其移位次数可达255次.<br>
移位一次时, 可直接用操作码. 如 SHL AX,1.<br>
移位&gt;1次时, 则由寄存器CL给出移位次数.<br>
如 MOV CL,04<br>
SHL AX,CL</p>
<h2 id="四-串指令-2">四、串指令</h2>
<p>───────────────────────────────────────<br>
DS:SI 源串段寄存器 :源串变址.<br>
ES:DI 目标串段寄存器:目标串变址.<br>
CX 重复次数计数器.<br>
AL/AX 扫描值.<br>
D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量.<br>
Z标志 用来控制扫描或比较操作的结束.<br>
MOVS 串传送.<br>
( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )<br>
CMPS 串比较.<br>
( CMPSB 比较字符. CMPSW 比较字. )<br>
SCAS 串扫描.<br>
把AL或AX的内容与目标串作比较,比较结果反映在标志位.<br>
LODS 装入串.<br>
把源串中的元素(字或字节)逐一装入AL或AX中.<br>
( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )<br>
STOS 保存串.<br>
是LODS的逆过程.<br>
REP 当CX/ECX&lt;&gt;0时重复.<br>
REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复.<br>
REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复.<br>
REPC 当CF=1且CX/ECX&lt;&gt;0时重复.<br>
REPNC 当CF=0且CX/ECX&lt;&gt;0时重复.</p>
<h2 id="五-程序转移指令-2">五、程序转移指令</h2>
<p>───────────────────────────────────────<br>
1&gt;无条件转移指令 (长转移)<br>
JMP 无条件转移指令<br>
CALL 过程调用<br>
RET/RETF过程返回.<br>
2&gt;条件转移指令 (短转移,-128到+127的距离内)<br>
( 当且仅当(SF XOR OF)=1时,OP1 JA/JNBE 不小于或不等于时转移.<br>
JAE/JNB 大于或等于转移.<br>
JB/JNAE 小于转移.<br>
JBE/JNA 小于或等于转移.<br>
以上四条,测试无符号整数运算的结果(标志C和Z).<br>
JG/JNLE 大于转移.<br>
JGE/JNL 大于或等于转移.<br>
JL/JNGE 小于转移.<br>
JLE/JNG 小于或等于转移.<br>
以上四条,测试带符号整数运算的结果(标志S,O和Z).<br>
JE/JZ 等于转移.<br>
JNE/JNZ 不等于时转移.<br>
JC 有进位时转移.<br>
JNC 无进位时转移.<br>
JNO 不溢出时转移.<br>
JNP/JPO 奇偶性为奇数时转移.<br>
JNS 符号位为 &quot;0&quot; 时转移.<br>
JO 溢出转移.<br>
JP/JPE 奇偶性为偶数时转移.<br>
JS 符号位为 &quot;1&quot; 时转移.<br>
3&gt;循环控制指令(短转移)<br>
LOOP CX不为零时循环.<br>
LOOPE/LOOPZ CX不为零且标志Z=1时循环.<br>
LOOPNE/LOOPNZ CX不为零且标志Z=0时循环.<br>
JCXZ CX为零时转移.<br>
JECXZ ECX为零时转移.<br>
4&gt;中断指令<br>
INT 中断指令<br>
INTO 溢出中断<br>
IRET 中断返回<br>
5&gt;处理器控制指令<br>
HLT 处理器暂停, 直到出现中断或复位信号才继续.<br>
WAIT 当芯片引线TEST为高电平时使CPU进入等待状态.<br>
ESC 转换到外处理器.<br>
LOCK 封锁总线.<br>
NOP 空操作.<br>
STC 置进位标志位.<br>
CLC 清进位标志位.<br>
CMC 进位标志取反.<br>
STD 置方向标志位.<br>
CLD 清方向标志位.<br>
STI 置中断允许位.<br>
CLI 清中断允许位.</p>
<h2 id="六-伪指令-2">六、伪指令</h2>
<p>─────────────────────────────────────<br>
DW 定义字(2字节).<br>
PROC 定义过程.<br>
ENDP 过程结束.<br>
SEGMENT 定义段.<br>
ASSUME 建立段寄存器寻址.<br>
ENDS 段结束.<br>
END 程序结束.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编语言笔记（第二章）]]></title>
        <id>https://zy080080.github.io//post/hui-bian-yu-yan-bi-ji-di-er-zhang</id>
        <link href="https://zy080080.github.io//post/hui-bian-yu-yan-bi-ji-di-er-zhang">
        </link>
        <updated>2019-09-10T10:07:01.000Z</updated>
        <summary type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
]]></summary>
        <content type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
<!-- more -->
<h1 id="第二章-寄存器">第二章 寄存器</h1>
<p> 一个典型的CPU由运算器、控制器、寄存器（CPU工作原理）等器件构成，这些器件靠内部总线相连，前一章的总栈相对于CPU内部来说是外部总线。内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其他器件的联系。在CPU中：</p>
<ul>
<li>运算器进行信息处理；</li>
<li>寄存器进行信息储存；</li>
<li>控制器控制各种器件进行工作；</li>
<li>内部总栈链接各种器件，在他们之间进行数据的传送。</li>
</ul>
<p> 对于一个汇编程序员来说，CPU中的主要部件是寄存器。寄存器是CPU中程序员可以用指令读写的部件。通过改变各种寄存器中的内容来实现对CPU的控制。</p>
<h2 id="21-通用寄存器">2.1 通用寄存器</h2>
<p> 8086CPU的所有寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这四个寄存器通常用来存放一般性的数据，被称为通用寄存器。<br>
 8086CPU的上一代CPU中的寄存器都是8位的，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在8086上，8086CPU的AX、BX、CX、DX这四个寄存器都可以分为两个可独立使用的8位寄存器来用：</p>
<ul>
<li>AX可分为AH和AL；</li>
<li>BX可分为BH和BL；</li>
<li>CX可分为CH和CL；</li>
<li>DX可分为DH和DL。</li>
</ul>
<p> AX的低8位（0位<sub>7位）构成了AL寄存器，高8位（8位</sub>15位）构成了AH寄存器。</p>
<blockquote>
<p>图例见教材P15。</p>
</blockquote>
<h2 id="22-字在寄存器中的储存">2.2 字在寄存器中的储存</h2>
<p> 出于对兼容性的考虑，8086CPU可以一次性处理一下两种尺寸的数据：</p>
<ul>
<li>字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。</li>
<li>字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">01001110</th>
<th style="text-align:center">00100000</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">高位字节</td>
<td style="text-align:center">低位字节</td>
</tr>
</tbody>
</table>
<h2 id="23-几条汇编指令">2.3 几条汇编指令</h2>
<table>
<thead>
<tr>
<th style="text-align:left">汇编指令</th>
<th style="text-align:left">控制CPU完成的操作</th>
<th style="text-align:left">用高级语言的语法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">mov ax,18</td>
<td style="text-align:left">将18送入寄存器AX</td>
<td style="text-align:left">AX=18</td>
</tr>
<tr>
<td style="text-align:left">mov ah,78</td>
<td style="text-align:left">将78送入寄存器AH</td>
<td style="text-align:left">AH=78</td>
</tr>
<tr>
<td style="text-align:left">add ax,8</td>
<td style="text-align:left">将寄存器AX中的数值加上8</td>
<td style="text-align:left">AX=AX+8</td>
</tr>
<tr>
<td style="text-align:left">mov ax,bx</td>
<td style="text-align:left">将寄存器BX中的数据送入寄存器AX</td>
<td style="text-align:left">AX=BX</td>
</tr>
<tr>
<td style="text-align:left">add ax bx</td>
<td style="text-align:left">将AX和BX中的数值相加，结果存在AX中</td>
<td style="text-align:left">AX=AX+BX</td>
</tr>
</tbody>
</table>
<h2 id="24-物理地址">2.4 物理地址</h2>
<p> CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的储存空间是一个一维的线性空间，每一个内存单元在这个空间都有唯一的地址，我们将其称为物理地址。<br>
 CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU有不同的形成物理地址的方式。在此我们讨论8086CPU。</p>
<h2 id="25-16位结构的cpu">2.5 16位结构的CPU</h2>
<p> 概括地讲，16位结构（16位机，字长为16位等常见说法，与16位结构的含义相同）描述了一个CPU具有下面几方面的结构特性。</p>
<ul>
<li>运算器一次最多可处理16位的数据；</li>
<li>寄存器的最大宽度位16位；</li>
<li>寄存器和运算器之间的通路位16位。<br>
 8086是16位结构的CPU，也就是说，在8086内部，能够一次性处理、传输、暂时储存的信息的最大长度是16位的。内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次性处理、传输、暂时存储16位的地址。</li>
</ul>
<h2 id="26-8086cpu给出物理地址的方法">2.6 8086CPU给出物理地址的方法</h2>
<p> 8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理、船速、暂时储存的地址为16位。从8086CPU的内部结构来看，如果将地址从内部简单的发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。<br>
 8086CPU采用一中在内部用两个16位地址合成的方法来形成一个20位的物理地址。当8086CPU要读写内存时：</p>
<ol>
<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；</li>
<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；</li>
<li>地址加法器将两个16位地址合成为一个20位的物理地址；</li>
<li>地址加法器通过<mark>内部总线</mark>将20位物理地址送入输入输出控制电路；</li>
<li>输入输出控制电路将20位物理地址送上地址总线；</li>
<li>20位物理地址被地址总线传送到存储器（内存）。</li>
</ol>
<p> 地址加法器采用<strong>物理地址=段地址x16+偏移地址</strong>的方式用段地址和偏移地址合成物理地址。</p>
<blockquote>
<h3 id="由-段地址x16-引发的讨论">由 段地址x16 引发的讨论</h3>
<p> “段地址x16”有一个更为常用的说法是左移4位。计算机中的所有信息都是以二进制的形式存储的，段地址也不例外。机器智能处理而禁止信息，”左移4位“中的位，指的是二进制位<br>
 一个X进制的数据左移1位，相当于乘以X。</p>
</blockquote>
<h2 id="27-段地址x16偏移地址物理地址的本质含义">2.7 “段地址x16+偏移地址=物理地址”的本质含义</h2>
<p> “段地址x16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地质（段地址x16）和一个相对与基础地址的偏移地址相加，给出内存单元的物理地址。<br>
 更一般地说，8086CPU这种寻址功能是“基础地质+偏移地址=-物理地址”寻址模式的一种具体实现方案。<br>
 下面比喻说明。<br>
 比如说，学校、体育馆、图书馆在一条笔直的单行路上，学校位于路的起点。</p>
<table>
<thead>
<tr>
<th>学校</th>
<th>-2 0 0 0 米-</th>
<th>体育馆</th>
<th>-8 2 6 米-</th>
<th>图书馆</th>
</tr>
</thead>
<tbody>
<tr>
<td>0米</td>
<td>----------→</td>
<td>2000米</td>
<td>----------→</td>
<td>2826米</td>
</tr>
</tbody>
</table>
<p> 你要去图书馆，问我那里的地址，我可以用两种方式告诉你图书馆的地址：</p>
<ol>
<li>从学校走2826m到图书馆。这2826m可以认为是图书馆的物理地址。</li>
<li>从学校走2000m到体育馆，从体育馆再走826m到图书馆。第一个距离2000m是相当于起点的基础地址，第二个距离826m是相对于基础地址的偏移地址（以基础地址为起点的地址）。</li>
</ol>
<p> 第一种方式直接给出物理地址2826m，第二种方式使用基础地址和偏移地址相加来得到物理地址的。<br>
 我们为上面的例子加一些限制条件，比如只能通过纸条来互相通信，如果我有一张可以容纳4位数据的纸条，我可以写下2826这个数据。</p>
<table>
<thead>
<tr>
<th>2</th>
<th>8</th>
<th>2</th>
<th>6</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p> 可不巧的是我仅有两张可以容纳三位数据的纸条。这样我只能通过这总方式来传达数据。</p>
<table>
<thead>
<tr>
<th>2</th>
<th>0</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>2</td>
<td>6</td>
</tr>
</tbody>
</table>
<p> 假设我们事先约定，得到两张之后做这样的运算：</p>
<ul>
<li>200（段地址）x10 + 826（偏移地址） = 2826（物理地址）</li>
</ul>
<h2 id="28-段的概念">2.8 段的概念</h2>
<p> 内存并没有分段，段的划分来自于CPU，由于8086CPU用“基础地质+偏移地址=-物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。<br>
 在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址x16的起始地址（基础地址），用偏移地址定位段中的内存单元。</p>
<blockquote>
<h3 id="内存单元地址小结">内存单元地址小结</h3>
<p> CPU可以用不同的段地址和偏移地址形成同一个物理地址。</p>
<ul>
<li>例如CPU要访问21F60H单元，则它给出的段地址SA和偏移地址EA满足SAx16+EA=21F60H即可。</li>
</ul>
<p> 偏移地址16位，变化范围为0~FFFFH，仅用偏移地址来寻址最多可寻64KB个内存单元。</p>
<ul>
<li>比如给定段地址1000H，用偏移地址寻址，CPU的寻址范围为：10000H~1FFFFH。</li>
</ul>
<p> “数据在21F60H中。”这句话对于8086CPU机一般不这样讲，取而代之的是两种类似的说法：</p>
<ol>
<li>数据存在内存 2000:1F60 中；</li>
<li>数据存在内存的2000H段中的1F60H单元中。</li>
</ol>
</blockquote>
<blockquote>
<h3 id="检测点22">检测点2.2</h3>
<p> 有一数据存放在内存20000H单元中，现给定段地址位SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为（1001H），最大为（2000H）。</p>
<blockquote>
<p>网上给出的解析：20000H - FFFFH/10H = 2000H - 0FFFH = 1001H</p>
</blockquote>
<blockquote>
<p>个人思考：20000H - FFFFH = 10001H，右移一位成为1000H，但是不够的，所以最小应为1001H。</p>
</blockquote>
</blockquote>
<h2 id="29-段存器">2.9 段存器</h2>
<p>​ 段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。本章只看一下CS。</p>
<h2 id="210-cs和ip">2.10 CS和IP</h2>
<p> CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前尧都区指令的地址。CS为代码段寄存器，IP位指令指针寄存器。<br>
 8086机中，任意时刻，CPU将 CS:IP 指向的内容当做指令执行。</p>
<blockquote>
<p>图解看书P26。</p>
</blockquote>
<p> 在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，CPU从内存 FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。<br>
 在任何时候，CPU将CS、IP中的内容当做指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。如果说，内存中的一段信息曾被CPU执行过的话，那么，他所在的内存单元必然被 CS:IP 指向过。</p>
<h2 id="211-修改cs-ip的指令">2.11 修改CS、IP的指令</h2>
<p> 在CPU中，程序员能够用指令修改的部件只有寄存器，可以通过改变CS、IP中的内容来控制CPU执行目标指令。<br>
 jmp指令</p>
<ul>
<li>若想同时修改CS、IP的内容，可用形如“jmp 段地址：偏移地址”的指令完成，如
<ul>
<li>jmp 2AE3:3，执行后： CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令。</li>
</ul>
</li>
<li>若只想修改IP的内容，可用形如“jmp 某一合法寄存器”的指令完成，如：
<ul>
<li>jmp ax<br>
指令执行前：ax=1000H, CS=2000H, IP=0003H<br>
执行后：ax=1000H, CS=2000H, IP=1000H</li>
</ul>
</li>
</ul>
<p> jmp ax，在含义上好似： mov IP,ax。</p>
<blockquote>
<h3 id="检测点23">检测点2.3</h3>
<p>下面的三条指令执行后，CPU几次修改IP？都是在什么时候？最后IP中的值是多少？<br>
(1) mov ax,bx<br>
(2) sub ax,ax<br>
(3) jmp ax</p>
<p>答案：四次</p>
<ul>
<li>第一次：(1)执行前</li>
<li>第二次：(2)执行前</li>
<li>第三次：(3)执行前</li>
<li>第四次：jmp指令执行后，IP变为0</li>
</ul>
<p>注：指令在被传到指令缓冲器，被执行前IP自动指向下一指令。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The way to make sure never to draw a number twice]]></title>
        <id>https://zy080080.github.io//post/the-way-to-make-sure-never-to-draw-a-number-twice</id>
        <link href="https://zy080080.github.io//post/the-way-to-make-sure-never-to-draw-a-number-twice">
        </link>
        <updated>2019-09-09T16:02:54.000Z</updated>
        <summary type="html"><![CDATA[<p> When we draw k numbers from numbers[n], how to be sure never to draw a number again?</p>
]]></summary>
        <content type="html"><![CDATA[<p> When we draw k numbers from numbers[n], how to be sure never to draw a number again?</p>
 <!-- more --> 
<p> This program draws a random combination of numbers for a lottery game.<br>
 The way to draw a number just once is :</p>
<blockquote>
<p> To overwrite numbers[r] with the last number in the array and reduce n by 1.</p>
</blockquote>
<p> 将原本number[r]的元素移除后，通过n每次的缩小随机数产生的范围避免重复。</p>
<pre><code>import java.util.*;

public class LotteryDrawing {
	public static void main (String[] args) {
		Scanner in = new Scanner(System.in);
	
		System.out.print(&quot;How many numbers do you need to draw? &quot;);
		int k = in.nextInt();
	
		System.out.print(&quot;What is the highest numbers you can draw? &quot;);
		int n = in.nextInt();
	
		//fill an arry with numbers 1 2 3. . .n
		int[] numbers = new int[n];
		for(int i = 0; i &lt; numbers.length; i++) {
			numbers[i] = i + 1;
		}
		
		//draw k numbers and put them into a second array
		int[] result = new int[k];
		for(int i = 0; i &lt; result.length; i++) {
			//make a random index between 0 and n - 1
			int r = (int)(Math.random() * n);
			
			//pick the element at the random location
			result[i] = numbers[r];
			
			//move the last element into the random location
			numbers[r] = numbers[n - 1];
			n--;
		}
	
		//print the sorted array
		Arrays.sort(result);
		System.out.println(&quot;Bet the following combination. It'll make you rich!&quot;);
		for(int r : result) {
			System.out.print(r + &quot; &quot;);
		}
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编语言笔记（第一章）]]></title>
        <id>https://zy080080.github.io//post/hui-bian-yu-yan-bi-ji</id>
        <link href="https://zy080080.github.io//post/hui-bian-yu-yan-bi-ji">
        </link>
        <updated>2019-09-09T04:28:56.000Z</updated>
        <summary type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
]]></summary>
        <content type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
<!-- more -->
<h1 id="第一章">第一章</h1>
<h2 id="1基础知识">1.基础知识</h2>
<h3 id="11-机器语言">1.1 机器语言</h3>
<ul>
<li>电子计算机的机器指令是一列二进制数字。计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算。</li>
<li>现在我们常用的PC机中，有一个芯片来完成上面所说的计算机的功能。这个芯片是CPU（Central Processing Unit），是一种微型处理器。</li>
</ul>
<h3 id="14-储存器">1.4 储存器</h3>
<ul>
<li>要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在储存器中存放，也就是我们平时所说的内存。</li>
<li>磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被CPU使用。</li>
</ul>
<h3 id="16-储存单元">1.6 储存单元</h3>
<ul>
<li>储存器被划分成若干个储存单元，每个储存单元从0开始顺序编号，例如一个储存器有128个储存单元，编号从0~127。</li>
<li><strong>微型机储存器的储存单元可以储存一个Byte</strong>，即8个二进制单位（bit）。一个储存器有128个储存单元，它可以储存128个Byte。</li>
<li>微机储存器的容量是以字节为最小单位来计算的。对于拥有128个储存单元的储存器，我们可以说，它的容量是128个字节。</li>
</ul>
<h3 id="17-cpu对储存器的读写">1.7 CPU对储存器的读写</h3>
<ul>
<li>CPU想要进行数据的读写，必须和外部器件（标准的说法是芯片）进行下面三类信息的交互。
<ul>
<li>储存单元的地址（地址信息）。</li>
<li>器件的选择，读说写的命令（控制信息）。</li>
<li>读或写的数据（数据信息）。</li>
</ul>
</li>
<li>地址总线、数据总线和控制总线。
<ul>
<li>地址总线的宽度决定了CPU的寻地址能力，一个CPU有N根地址总线，则可以说这个CPU的地址总线跨度为N。这样的CPU最多可以寻找2的N次方个内存单元。</li>
<li>数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量，决定了CPU和外接的数据传送速度。8根数据总线一次可以传送一个8位二进制数据（即一个字节）。16根数据总线一次可以传送两个字节。</li>
<li>控制总线的宽度决定了CPU对系统中其他器件的控制能力。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="检测点11">检测点1.1</h4>
<p>1个CPU的寻地址能力是8KB，那么他的地址总线的宽度为<u>13</u>。（以二为底的log(8*1024)）<br>
可寻址2^10个内存单元 = 2^10 Byte内存单元。<br>
2^20 个不同的数据 = (2^20)/1024 = 1024KB 不同数据 = 1MB不同数据。</p>
</blockquote>
<h3 id="114-各类储存器芯片">1.14 各类储存器芯片</h3>
<ul>
<li>随机储存器（RAM），可读可写但必须带电储存，关机后储存的内容消失。<br>
用于存放供CPU使用的决大份程序个数据，主随机储存器一般由两个位置上的RAM组成，装在主板上的RAM和插在扩展插槽上的RAM。</li>
<li>装有BIOS（Basic Input/Output System，基本输入/输出系统）的ROM。<br>
BIOS是由主板和各类接口卡（显卡网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。<br>
在主板和某些接口卡上插有储存相应BIOS的ROM。例如，主板上的ROM中分储存着主板的BIOS（通常称为系统BIOS）；显卡上的ROM中储存着显卡的BIOS。</li>
<li>接口卡上的RAM。<br>
某些接口卡需要对大批量输入、输出数据进行暂时储存，在其上装有RAM。最典型的是显示卡上的RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。</li>
</ul>
<h3 id="115-内存地址空间">1.15 内存地址空间</h3>
<p> 上述的那些储存器，在物理上是独立的器件，但是在以下两点上相同：</p>
<ul>
<li>都和CPU的总线相连。</li>
<li>CPU对他们进行读或写的时候都通过控制总线发出内存读写命令。</li>
</ul>
<p> 所有的物理储存器被看作一个由若干储存单元组成的逻辑储存器，每个物理储存器在这个逻辑储存器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理储存器中读写数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java time !]]></title>
        <id>https://zy080080.github.io//post/java-time</id>
        <link href="https://zy080080.github.io//post/java-time">
        </link>
        <updated>2019-08-23T17:21:07.000Z</updated>
        <summary type="html"><![CDATA[<p>  It's time to learn something in English.</p>
]]></summary>
        <content type="html"><![CDATA[<p>  It's time to learn something in English.</p>
<!-- more --> 
<p>  These days, I'm learning Java by watching videoes. Though I'd been learning Java for half a year, but meanwhile I was preparing my college entrance exam. so I could not concentrate on programming. I think it is necessary to have a review because in next term I'm going to attend Java class which is taught in Japanese.<br>
  It's kind of a difficult stuff that learning something in three languages. I'm trying to review what I have learned by using a book called 'Head First Java', the English version.</p>
<hr>
<br>
<p><img src="https://zy080080.github.io//post-images/1566570199123.png" alt=""><br>
 整个暑假都在折腾英语和Java了....最近打算把汇编的书看一看，提前预习免得下学期忙不过来</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[My First Personal Blog]]></title>
        <id>https://zy080080.github.io//post/my-first-personal-blog</id>
        <link href="https://zy080080.github.io//post/my-first-personal-blog">
        </link>
        <updated>2019-08-22T11:06:53.000Z</updated>
        <summary type="html"><![CDATA[<p> I watched a video on bilibili in which the author suggests that people who want to work at an IT company should start a blog. So I took whole day to figure out how to create a blog in github.</p>
]]></summary>
        <content type="html"><![CDATA[<p> I watched a video on bilibili in which the author suggests that people who want to work at an IT company should start a blog. So I took whole day to figure out how to create a blog in github.</p>
<!-- more --> 
<p> This is the first article I have written to celebrate the opening of my personal blog which at last ran successfully in 20190821. I'm going to use it as a technology blog and put any note on it which is important in programming or anything else computer involved.<br>
 I'll try my best to write articles in English. I hope this is a good challenge and a good chance to prove my proficiency in English.<br>
 Never Stop Learning.<br>
 厚积薄发。</p>
]]></content>
    </entry>
</feed>