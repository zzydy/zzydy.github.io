<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy080080.github.io/</id>
    <title>听故事的人</title>
    <updated>2020-02-25T23:05:25.924Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy080080.github.io/"/>
    <link rel="self" href="https://zy080080.github.io/atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://zy080080.github.io/images/avatar.png</logo>
    <icon>https://zy080080.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 听故事的人</rights>
    <entry>
        <title type="html"><![CDATA[The relation among Frame, Container, Component]]></title>
        <id>https://zy080080.github.io/post/h3kJtgJgp/</id>
        <link href="https://zy080080.github.io/post/h3kJtgJgp/">
        </link>
        <updated>2020-02-25T23:58:07.000Z</updated>
        <summary type="html"><![CDATA[<p>References from API</p>
]]></summary>
        <content type="html"><![CDATA[<p>References from API</p>
<!-- more -->
<ul>
<li>java.lang.Object
<ul>
<li>java.awt.Component
<ul>
<li>java.awt.Container
<ul>
<li>java.awt.Window
<ul>
<li>java.awt.Frame</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>A component is an object having a graphical representation that can be displayed on the screen and that can interact with the user. Examples of components are the buttons, checkboxes, and scrollbars of a typical graphical user interface.</p>
<p>A generic Abstract Window Toolkit(AWT) container object is a component that can contain other AWT components.</p>
<p>A Window object is a top-level window with no borders and no menubar. The default layout for a window is BorderLayout.<br>
A window must have either a frame, dialog, or another window defined as its owner when it's constructed.</p>
<p>A Frame is a top-level window with a title and a border.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scanner-java.util.NoSuchElementException]]></title>
        <id>https://zy080080.github.io/post/9KbTa6Jc8/</id>
        <link href="https://zy080080.github.io/post/9KbTa6Jc8/">
        </link>
        <updated>2020-01-17T16:45:54.000Z</updated>
        <content type="html"><![CDATA[<pre><code>package exceptionTest;

import java.util.Scanner;

public class ScannerExceptionTest {
    public static void main(String[] args) {
    	Scanner sc = new Scanner(System.in);

    	sc.close();

    	Scanner scan = new Scanner(System.in);
	    int num = scan.nextInt();
	    System.out.println(num);
    }
}
</code></pre>
<p>出现异常</p>
<pre><code>Exception in thread &quot;main&quot; java.util.NoSuchElementException
    at java.util.Scanner.throwFor(Scanner.java:862)
    at java.util.Scanner.next(Scanner.java:1485)
    at java.util.Scanner.nextInt(Scanner.java:2117)
    at java.util.Scanner.nextInt(Scanner.java:2076)
    at exceptionTest.ScannerExceptionTest.main(ScannerExceptionTest.java:12)
</code></pre>
<p>close()方法被调用时，导致标准输入System.in的关闭，<strong>关闭后无法再次打开</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程的状态转换图]]></title>
        <id>https://zy080080.github.io/post/9uq8XXg02/</id>
        <link href="https://zy080080.github.io/post/9uq8XXg02/">
        </link>
        <updated>2020-01-13T03:00:10.000Z</updated>
        <content type="html"><![CDATA[<p>Thread</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IO Stream总结]]></title>
        <id>https://zy080080.github.io/post/wgV5DncBt/</id>
        <link href="https://zy080080.github.io/post/wgV5DncBt/">
        </link>
        <updated>2019-12-07T14:25:56.000Z</updated>
        <summary type="html"><![CDATA[<p>IO流种类虽然多，但用法基本相同。</p>
]]></summary>
        <content type="html"><![CDATA[<p>IO流种类虽然多，但用法基本相同。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://zy080080.github.io//post-images/1575721507863.png" alt="" loading="lazy"></figure>
<h2 id="字节流">字节流</h2>
<h3 id="字节输入流">字节输入流</h3>
<h4 id="inputstream">InputStream</h4>
<ul>
<li>方法及子类
<ul>
<li>int read() : 一次读取一个字节</li>
<li>int read(byte[] bys) : 一次读取一个字节数组</li>
</ul>
</li>
<li>FileInputStream</li>
<li>BufferedInputStream</li>
</ul>
<h3 id="字节输出流">字节输出流</h3>
<h4 id="outputstream">OutputStream</h4>
<ul>
<li>方法及子类
<ul>
<li>void write(int by) : 一次写一个字节</li>
<li>void write(byte[] bys, int i, int len) : 一次写一个字节数组的一部分</li>
</ul>
</li>
<li>FileOutputStream</li>
<li>BufferedOutputStream</li>
</ul>
<h2 id="转换流">转换流</h2>
<ul>
<li>InputStreamReader(InputStream is)</li>
<li>OutputStreamWriter(OutputStream os)</li>
</ul>
<h2 id="字符流-字节流-编码表">字符流 = 字节流 + 编码表</h2>
<h3 id="字符输入流">字符输入流</h3>
<h4 id="reader">Reader</h4>
<ul>
<li>方法及子类
<ul>
<li>int read() : 一次读取一个字符</li>
<li>int read(char[] chs) : 一次读取一个字符数组</li>
</ul>
</li>
<li>InputStreamReader
<ul>
<li>FileReader</li>
</ul>
</li>
<li>BufferedReader
<ul>
<li>String readLine() : 一次读取一行数据</li>
</ul>
</li>
</ul>
<h3 id="字符输出流">字符输出流</h3>
<h4 id="writer">Writer</h4>
<ul>
<li>方法及子类
<ul>
<li>void write(int ch) : 一次写一个字符</li>
<li>void write(char[] chs, int i, int len) : 一次写一个字符数组的一部分</li>
</ul>
</li>
<li>OutputStreamWriter
<ul>
<li>FileWriter</li>
</ul>
</li>
<li>BufferedWriter
<ul>
<li>void newLine() : 写换行符号</li>
<li>void write(String s) : 写一个字符串</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机如何识别中文字符]]></title>
        <id>https://zy080080.github.io/post/7045yjWiy/</id>
        <link href="https://zy080080.github.io/post/7045yjWiy/">
        </link>
        <updated>2019-11-30T14:32:11.000Z</updated>
        <summary type="html"><![CDATA[<p>使用字节输入流将中文字符打印到控制台时往往无法识别，而使用字节流复制文件却可以完美显示，计算机是如何识别中文字符的呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用字节输入流将中文字符打印到控制台时往往无法识别，而使用字节流复制文件却可以完美显示，计算机是如何识别中文字符的呢？</p>
<!-- more -->
<pre><code>String str = &quot;中文输入&quot;;
byte[] by = str.getBytes();
System.out.println(by.toString());

//输出打印结果为[-28, -72, -83, -26, -106, -121, -24, -66, -109, -27, -123, -91]
</code></pre>
<p>遇到负数时，自动与下一个数拼接，得到中文字符。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[流的关闭方式]]></title>
        <id>https://zy080080.github.io/post/RtEn3DuwS/</id>
        <link href="https://zy080080.github.io/post/RtEn3DuwS/">
        </link>
        <updated>2019-11-15T13:13:12.000Z</updated>
        <summary type="html"><![CDATA[<p> 所有的流都应该在使用完毕后关闭。如果不关闭，会占用资源。</p>
]]></summary>
        <content type="html"><![CDATA[<p> 所有的流都应该在使用完毕后关闭。如果不关闭，会占用资源。</p>
<!-- more -->
<h2 id="在try中关闭">在try中关闭</h2>
<p> 有隐患。如果文件不存在或者在读取时出现异常，关闭流的方法不会被执行。 <strong>不推荐使用</strong></p>
<h2 id="在finally中关闭">在finally中关闭</h2>
<p> 这是标准的关闭流的方式。<br>
 在关闭时，需要进行一次try catch处理。<br>
 在写不重要的代码时可以采用try中关闭，不麻烦。</p>
<pre><code>try {
    FileOutputStream fos = new FileOutputStream(f);
    fos.write(data1);
    fos.write(data2);
    fos.write(data4);
    fos.write(data3);
    //fos.close();  
} catch (IOException e) {
    e.printStackTrace();
}finally {
    try {
        fos.close();
    }catch(IOException e) {
        e.printStackTrace();
    }
}
</code></pre>
<h2 id="使用try的方式">使用try()的方式</h2>
<p> 把流定义在try()里,try,catch或者finally结束的时候，会自动关闭。<br>
 这种编写代码的方式叫做 <mark>try-with-resources</mark>， 这是从JDK7开始支持的技术<br>
 所有的流，都实现了一个接口叫做 <mark>AutoCloseable</mark>，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。</p>
<pre><code>public static void main(String[] args) {
File f = new File(&quot;d:/lol.txt&quot;);

    //把流定义在try()里,try,catch或者finally结束的时候，会自动关闭
    try (FileInputStream fis = new FileInputStream(f)) {
        byte[] all = new byte[(int) f.length()];
        fis.read(all);
        for (byte b : all) {
            System.out.println(b);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[异常 Exception]]></title>
        <id>https://zy080080.github.io/post/jfUUCCexq/</id>
        <link href="https://zy080080.github.io/post/jfUUCCexq/">
        </link>
        <updated>2019-11-12T15:24:40.000Z</updated>
        <summary type="html"><![CDATA[<p>异常分为运行时异常（可查异常）和非运行时异常（不可查异常），他们的主要区别是……</p>
]]></summary>
        <content type="html"><![CDATA[<p>异常分为运行时异常（可查异常）和非运行时异常（不可查异常），他们的主要区别是……</p>
<!-- more -->
<h2 id="可查异常-checkedexception">可查异常 CheckedException</h2>
<p>可查异常是必须进行处理的异常，要么try catch住，要么往外抛，谁调用，谁处理，比如 FileNotFoundException。</p>
<p>如果不处理，<mark><strong>编译器就不让你通过</strong></mark></p>
<h2 id="运行时异常-runtimeexception">运行时异常 RuntimeException</h2>
<p>常见运行时异常（不可查异常）：</p>
<ul>
<li>除数不能为0异常 ArithmeticException</li>
<li>下标越界异常 ArrayIndexOutOfBoundsException</li>
<li>空指针异常 NullPointerException</li>
</ul>
<p>在编写代码的时候，依然可以使用try cathc throws进行处理，与可查异常（非运行时异常）不同之处在于：</p>
<ul>
<li>即使不进行try catch，也 <mark><strong>不会有编译错误</strong></mark></li>
</ul>
<p>Java之所以设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常<strong>太过于普遍</strong>，如果都需要进行捕捉，代码的可读性就会变得很糟。</p>
<h2 id="错误-error">错误 Error</h2>
<p>指的是系统级别的异常，通常是内存用光了。</p>
<blockquote>
<p>总结：</p>
<p>运行时异常与非运行时异常的最大区别是，运行时异常（不可查异常）不需要进行显式的捕捉，编译器会让你通过。</p>
<p>而非运行时异常（可查异常）需要进行显式的捕捉，不然编译器不会让你通过。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ラズベリーパイ 4Bが起動しない時の対応法]]></title>
        <id>https://zy080080.github.io/post/1tSysQNzy/</id>
        <link href="https://zy080080.github.io/post/1tSysQNzy/">
        </link>
        <updated>2019-10-06T03:00:08.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a></p>
<!-- more -->
<p>ラズベリーパイを手に入れてからすぐにNOOBSでインストールしてみたが、起動できませんでした。<br>
そしてシステムを直接SDカードにインストールするのも試しましたが、同じく赤いLEDだけが点灯して、起動が失敗しました。</p>
<p>まだラズパイ４Bに関してネット上に乗っている情報が少ないですが、公式Webページから対応法が見つかりました。</p>
<blockquote>
<p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br>
If your Raspberry Pi 4 will not boot, it is possible that the SPI EEPROM has become corrupted.<br>
To check, remove the SD card, disconnect the device from power, then reconnect it. If the green LED does not flash, you will need to reprogram the EEPROM:</p>
<ul>
<li>Download the bootloader</li>
<li>Extract it to an empty FAT-formatted SD card and insert it into your Raspberry Pi 4</li>
<li>Connect the power and wait for the green LED to flash quickly</li>
</ul>
<p>Notes:</p>
<ul>
<li>The updated bootloader improves compatibility with HATs by changing the behaviour of HALT to keep the 3V3 pin powered (view the full bootloader release notes)</li>
<li>The previous bootloader remains available for download</li>
</ul>
</blockquote>
<p>やっぱり英語は大切ですね。。。。</p>
<p>ちなみに、SDカードをカードリーダに入れてUSBとしてラズパイに差し込んだ人もいたらしいですが、ちゃんと裏面にセットすれば問題ないはずです。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[A solution of unable to boot up Raspberry Pi 4B]]></title>
        <id>https://zy080080.github.io/post/dgAVKMhPS/</id>
        <link href="https://zy080080.github.io/post/dgAVKMhPS/">
        </link>
        <updated>2019-10-05T21:26:46.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
<!-- more -->
<p> I received my new Raspberry Pi yesterday. I tried to boot up the Pi in two ways, but it couldn't be boot.<br>
 At last, I found the solution on its homepage:</p>
<blockquote>
<p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br>
If your Raspberry Pi 4 will not boot, it is possible that the SPI EEPROM has become corrupted.<br>
To check, remove the SD card, disconnect the device from power, then reconnect it. If the green LED does not flash, you will need to reprogram the EEPROM:</p>
<ul>
<li>Download the bootloader</li>
<li>Extract it to an empty FAT-formatted SD card and insert it into your Raspberry Pi 4</li>
<li>Connect the power and wait for the green LED to flash quickly</li>
</ul>
<p>Notes:</p>
<ul>
<li>The updated bootloader improves compatibility with HATs by changing the behaviour of HALT to keep the 3V3 pin powered (view the full bootloader release notes)</li>
<li>The previous bootloader remains available for download</li>
</ul>
</blockquote>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决无法启动树莓派4B的问题]]></title>
        <id>https://zy080080.github.io/post/pE2JY0ig0/</id>
        <link href="https://zy080080.github.io/post/pE2JY0ig0/">
        </link>
        <updated>2019-10-05T16:34:08.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
<!-- more -->
<p> 昨天从日亚买的树莓派4B到货了，但是按网上说的无论是用NOOBS还是直接装系统都无法正常启动，一直处于红灯常亮状态。<br>
 找了半天相关消息都比较少，直到从官网看到：</p>
<blockquote>
<p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br>
If your Raspberry Pi 4 will not boot, it is possible that the SPI EEPROM has become corrupted.<br>
To check, remove the SD card, disconnect the device from power, then reconnect it. If the green LED does not flash, you will need to reprogram the EEPROM:</p>
<ul>
<li>Download the bootloader</li>
<li>Extract it to an empty FAT-formatted SD card and insert it into your Raspberry Pi 4</li>
<li>Connect the power and wait for the green LED to flash quickly</li>
</ul>
<p>Notes:</p>
<ul>
<li>The updated bootloader improves compatibility with HATs by changing the behaviour of HALT to keep the 3V3 pin powered (view the full bootloader release notes)</li>
<li>The previous bootloader remains available for download</li>
</ul>
</blockquote>
<p> 按照这个将下载的bootloader装进SD卡启动直到绿灯闪烁后，再次装NOOBS或者Raspbian系统，问题才得以解决。</p>
]]></content>
    </entry>
</feed>