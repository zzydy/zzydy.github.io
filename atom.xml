<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy080080.github.io/</id>
    <title>听故事的人</title>
    <updated>2019-09-20T02:51:14.902Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy080080.github.io/"/>
    <link rel="self" href="https://zy080080.github.io//atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://zy080080.github.io//images/avatar.png</logo>
    <icon>https://zy080080.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 听故事的人</rights>
    <entry>
        <title type="html"><![CDATA[Does Java pass by reference or pass by value?]]></title>
        <id>https://zy080080.github.io//post/fFi1CAqNV</id>
        <link href="https://zy080080.github.io//post/fFi1CAqNV">
        </link>
        <updated>2019-09-15T16:46:51.000Z</updated>
        <summary type="html"><![CDATA[<p>Source：<a href="https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html">https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>Source：<a href="https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html">https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html</a></p>
<!-- more -->
<p><a href="https://zy080080.github.io/post/UYqd_tZ7B/">点此查看相关中文文章</a></p>
<h2 id="q-learn-java-if-java-uses-the-pass-by-reference-why-wont-a-swap-function-work">Q: Learn Java: If Java uses the pass-by reference, why won't a swap function work?</h2>
<p>A: Java does manipulate objects by reference, and all object variables are references. However, Java doesn't pass method arguments by reference; it passes them by value.</p>
<p>Take the badSwap() method for example:</p>
<pre><code>public void badSwap(int var1, int var2)
{
 int temp = var1;
 var1 = var2;
 var2 = temp;
}
</code></pre>
<p>When badSwap() returns, the variables passed as arguments will still hold their original values. The method will also fail if we change the arguments type from int to Object, since Java passes object references by value as well. Now, here is where it gets tricky:</p>
<pre><code>public void tricky(Point arg1, Point arg2)
{
 arg1.x = 100;
 arg1.y = 100;
 Point temp = arg1;
 arg1 = arg2;
 arg2 = temp;
}
public static void main(String [] args)
{
 Point pnt1 = new Point(0,0);
 Point pnt2 = new Point(0,0);
 System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y: &quot; +pnt1.y); 
 System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);
 System.out.println(&quot; &quot;);
 tricky(pnt1,pnt2);
 System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y:&quot; + pnt1.y); 
 System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);  
}
</code></pre>
<p>If we execute this main() method, we see the following output:</p>
<pre><code>X: 0 Y: 0
X: 0 Y: 0
X: 100 Y: 100
X: 0 Y: 0
</code></pre>
<p>The method successfully alters the value of pnt1, even though it is passed by value; however, a swap of pnt1 and pnt2 fails! This is the major source of confusion. In the main() method, pnt1 and pnt2 are nothing more than object references. When you pass pnt1 and pnt2 to the tricky() method, Java passes the references by value just like any other parameter. This means the references passed to the method are actually copies of the original references. Figure 1 below shows two references pointing to the same object after Java passes an object to a method.</p>
<figure data-type="image" tabindex="1"><img src="https://images.techhive.com/images/idge/imported/article/jvw/2000/05/03-qa-0512-pass1-100158781-orig.gif" alt="Figure 1. After being passed to a method, an object will have at least two references"></figure>
<p>Java copies and passes the reference by value, not the object. Thus, method manipulation will alter the objects, since the references point to the original objects. But since the references are copies, swaps will fail. As Figure 2 illustrates, the method references swap, but not the original references. Unfortunately, after a method call, you are left with only the unswapped original references. For a swap to succeed outside of the method call, we need to swap the original references, not the copies.</p>
<p>O'Reilly's Java in a Nutshell by David Flanagan (see Resources) puts it best: &quot;Java manipulates objects 'by reference,' but it passes object references to methods 'by value.'&quot; As a result, you cannot write a standard swap method to swap objects.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编语言笔记（第三章）]]></title>
        <id>https://zy080080.github.io//post/lwMS0nfZZ</id>
        <link href="https://zy080080.github.io//post/lwMS0nfZZ">
        </link>
        <updated>2019-09-13T03:39:41.000Z</updated>
        <summary type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
]]></summary>
        <content type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
<!-- more -->
<h1 id="第三章-寄存器内存访问">第三章 寄存器（内存访问）</h1>
<h2 id="31-内存中字的存储">3.1 内存中字的存储</h2>
<p> CPU中用16位寄存器来存储一个字，高8位存放高位字节，低8位存放低位字节，在内存中储存时，由于内存单元是字节单元（一个字节存放一个单元），则一个字要用两个地址连续的内存单元来存放。</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>20H</td>
</tr>
<tr>
<td>1</td>
<td>4EH</td>
</tr>
<tr>
<td>2</td>
<td>12H</td>
</tr>
<tr>
<td>4</td>
<td>00H</td>
</tr>
<tr>
<td>5</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
</tr>
</tbody>
</table>
<p> 如表格，我们用0，1两个内存单元存放数据20000（4E20H）。4E20H的低位字节存放在0号单元中，高位字节存放在1号单元中。这两个内存单元可以看做一个起始地址为0的字单元（存放一个字的内存单元，由0、1两个字节单元组成）。数据18（0012H）同理。</p>
<h3 id="我们将起始地址为n的字单元简称为n地址字单元-比如一个字单元有2-3两个内存单元组成则这个字单元的起始地址为2我们可以说这是2地址字单元"> <strong>我们将起始地址为N的字单元简称为N地址字单元。比如一个字单元有2、3两个内存单元组成，则这个字单元的起始地址为2，我们可以说这是2地址字单元</strong></h3>
<h2 id="32-ds和adress">3.2 DS和[adress]</h2>
<p> CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086CPU中，内存地址由段地址和偏移地址组成。8086CPU中有个DS寄存器，通常用来存放要访问数据的段地址。比如我们要读取10000H单元的内容，可以用如下的程序段进行：</p>
<p>mov bx,1000H<br>
mov ds,bx<br>
mov al,[0]</p>
<p> 上面的三条指令将10000H（1000：0）中的数据读到al中<br>
 mov指令可以将一个内存单元中的内容送入一个寄存器中，内存单元需要用内存单元的地址来指明。格式为 mov 寄存器名，内存单元地址。<br>
 “[···]“表示一个内存单元，其中的内容表示内存单元的偏移地址。而段地址存储在DS寄存器中。<br>
 DS是一个段寄存器，8086CPU不支持将数据直接从入段寄存器的操作。 mov ds，1000H <strong>是非法的</strong></p>
<p> 数据还可以从寄存器送入内存单元，如：</p>
<pre><code>mov bx,1000H
mov ds,bx 
mov [0],al
</code></pre>
<h2 id="33-字的传送">3.3 字的传送</h2>
<p> 8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据，即一次性传送一个字。</p>
<pre><code>mov ax,1000H
mov ds,bx
mov ax,[0] //1000:0 处的字形数据送入ax
mov [0],cx //cx中的16位数据送到 1000:0 处
</code></pre>
<blockquote>
<p>注意：传送到ax，bx，cx的是字形数据，传送到al，ah，bl，bh的是字节型数据。</p>
</blockquote>
<h2 id="34-mov-add-sub指令">3.4 mov、add、sub指令</h2>
<p> 到现在，我们知道mov指令可以有以下几种形式：</p>
<pre><code>mov ax,8    //寄存器，数据
mov ax,bx   //寄存器，寄存器
mov ax,[0]  //寄存器，内存单元
mov [0],ax  //内存单元，寄存器
mov ds,ax   //段寄存器，寄存器
</code></pre>
<p> 利用Debug验证后，下列指令也可成立：</p>
<pre><code>mov ax,dx   //寄存器，段寄存器
mov [0],cs  //内存单元，段寄存器
mov ds,[0]  //段寄存器，内存单元
</code></pre>
<p> add和sub指令同mov一样，都有两个操作对象，它们也可以有以下几种形式：</p>
<pre><code>add ax,8    //寄存器，数据
add ax,bx   //寄存器，寄存器
add ax,[0]  //寄存器，内存单元
add [0],ax  //内存单元，寄存器
sub ax,9    //寄存器，数据
sub sx,bx   //寄存器，寄存器
sub ax,[0]  //寄存器，内存单元
sub [0],ax  //内存单元，寄存器
</code></pre>
<p> <mark>但他们无法对段寄存器操作</mark></p>
<h2 id="35-数据段">3.5 数据段</h2>
<p> 对于8086机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为N(N&lt;=64KB)、地址连续、起始地址为16的倍数的内存单元当做专门存储数据的内存空间，从而定义了一个数据段。<br>
 比如讲 123B0H~123B9H 的内存单元定义为数据段。现在要累加这个数据段中的前3个单元的数据，代码如下。</p>
<pre><code>mov ax,123BH    
mov ds,ax       //将123BH送入ds中，作为数据段的段地址
mov al,0        //用al存放累加结果
add al,[0]      //将数据段第一个单元（偏移地址为0）中的数值加到al中
add al,[1]      //将数据段第二个单元（偏移地址为0）中的数值加到al中
add al,[2]      //将数据段第三个单元（偏移地址为0）中的数值加到al中
</code></pre>
<h2 id="36-桟">3.6 桟</h2>
<p> 桟是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。</p>
<table>
<thead>
<tr>
<th style="text-align:center">桟</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">...</td>
</tr>
<tr>
<td style="text-align:center">...</td>
</tr>
<tr>
<td style="text-align:center">四单个数据</td>
</tr>
<tr>
<td style="text-align:center">第二个数据</td>
</tr>
<tr>
<td style="text-align:center">第一个数据</td>
</tr>
</tbody>
</table>
<p> 入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入桟，需要出栈时，由最先被从桟中取出。桟的这种操作规则被称为：LIFO（Last In First Out）。</p>
<h2 id="37-cpu提供的桟机制">3.7 CPU提供的桟机制</h2>
<p> 8086CPU提供入栈和出栈指令，最基本的两个是 PUSH（入栈）和 POP（出栈）。</p>
<pre><code>push ax //将寄存器ax中的数据送入桟中
pop ax  //从栈顶取出数据送入ax
</code></pre>
<p> <mark>8086CPU的入栈和出栈操作都是以<strong>字</strong>为单位进行的</mark></p>
<p> 8086CPU中，有两个寄存器，段寄存器 SS 和寄存器 SP，栈顶的段地址存放在 SS 中，偏移地址存放在 SP 中。任意时刻， SS:SP 指向<strong>栈顶元素</strong>。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。</p>
<p> push ax的执行，由以下两步组成。</p>
<ol>
<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶。</li>
<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。</li>
</ol>
<p> 8086CPU对push指令的执行过程：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
<th>SS:SP位置</th>
<th>当前状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SS=1000</td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SP=000E</td>
</tr>
<tr>
<td>1000B</td>
<td></td>
<td></td>
<td>AX=2266</td>
</tr>
<tr>
<td>1000C</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000D</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000E</td>
<td>23</td>
<td>←SS:SP</td>
<td></td>
</tr>
<tr>
<td>1000F</td>
<td>01</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p> ↑栈中原本存在数据0123H，此时SS:SP指向1000EH。</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
<th>SS:SP位置</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SS=1000</td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SP=000C</td>
</tr>
<tr>
<td>1000B</td>
<td></td>
<td></td>
<td>AX=2266</td>
</tr>
<tr>
<td>1000C</td>
<td></td>
<td>←SS:SP</td>
<td></td>
</tr>
<tr>
<td>1000D</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000E</td>
<td>23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000F</td>
<td>01</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p> ↑CPU执行push，第一步：SP=SP-2，SS:SP指向1000CH。</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
<th>SS:SP位置</th>
<th>当前状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SS=1000</td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SP=000C</td>
</tr>
<tr>
<td>1000B</td>
<td></td>
<td></td>
<td>AX=2266</td>
</tr>
<tr>
<td>1000C</td>
<td>66</td>
<td>←SS:SP</td>
<td></td>
</tr>
<tr>
<td>1000D</td>
<td>22</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000E</td>
<td>23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000F</td>
<td>01</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p> ↑CPU执行push，第二步：将AX中的数据送入SS:SP指向的内存单元处。</p>
<p> pop ax 的执行过程：</p>
<ol>
<li>将SS:SP指向的内存单元处的数据送入ax中。</li>
<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>
</ol>
<p>注意：出栈后，原本SS:SP指向的单元内的内容依然存在，但是它已经不在栈中。当再次执行push等入栈指令后，会被新数据覆盖。</p>
<h2 id="38-栈顶超界的问题">3.8 栈顶超界的问题</h2>
<p> 8086CPU不保证我对栈的操作不会越界。也就是说，8086CPU只知道栈顶在何处（SS:SP），而不知道我们安排的栈空间有多大。这好像CPU只知道当前要执行的指令在哪里（CS:IP），而不知道要执行的指令有多少。从这两点我们可以看出8086CPU的工作机理，它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。<br>
 我们在编程时要自己操心栈顶超界的问题。</p>
<h2 id="39-push-pop指令">3.9 push、pop指令</h2>
<p> push和pop指令的格式可以是如下形式：</p>
<pre><code>push 寄存器     //将一个寄存器的数据入栈
pop 寄存器      //出栈，用一个寄存器接收出栈的数据
</code></pre>
<p> 当然也可以是如下形式：</p>
<pre><code>push 段寄存器   //将一个段寄存器的数据入栈
pop 段寄存器    //出栈，用一个段寄存器接收出栈的数据
</code></pre>
<p> push和pop也可以在内存单元和内存单元之间传送数据：</p>
<pre><code>push 内存单元   //将一个内存字单元处的字入栈（**注意：栈操作都是以字为单位的**）
pop 内存单元    //出栈，用一个内存字单元接收出栈的数据
</code></pre>
<p> 比如：</p>
<pre><code>mov ax,1000H    
mov ds,ax       //内存单元的段地址要放在DS中
push [0]        //将1000：0处的字压入栈中
pop [2]         //出栈，出栈的数据送入1000：2处
</code></pre>
<p> 栈为空的情况：<br>
将10000~1000F当做栈，初始状态为空</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">内容</th>
<th>SS:SP指向</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10000</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">...</td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">...</td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1000C</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1000D</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1000E</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1000F</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">10010</td>
<td style="text-align:center">(其他内容)</td>
<td>←SS:SP</td>
</tr>
</tbody>
</table>
<p> 执行push时，CPU的两步操作是：先改变SP，后向SS:SP处传送。<br>
 执行pop时，CPU的两步操作是：先读取SS:SP处的数据，后改变SP。</p>
<p> 栈顶的变化范围：0~FFFFH。</p>
<h2 id="310-栈段">3.10 栈段</h2>
<p> 我们可以将长度为N（N&lt;=64KB）的一组地址连续、起始地址为16的倍数的内存单元当做栈来使用。</p>
<p> 如果将10000H~1FFFFH这段空间当做栈段，初始状态栈是空的，此时SS=1000H，<strong>SP=0</strong>。（任意时刻，SS:SP指向栈顶元素，当栈为空时，也就不存在栈顶元素，所以SS:SP只能指向站的最底部单元下面的单元，该单元的地址为栈最底部的字单元的地址+2。栈最底部字单元的地址为1000:FFFE，所以栈空时，SP=0000H）</p>
<h3 id="实验2">实验2：</h3>
<p> 当用T执行mov ss，ax（任何修改SS的指令）的时候，它的下一条指令也会被紧接着执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[StringBuffer作为参数传递问题]]></title>
        <id>https://zy080080.github.io//post/SbZ2wCsCd</id>
        <link href="https://zy080080.github.io//post/SbZ2wCsCd">
        </link>
        <updated>2019-09-12T09:12:57.000Z</updated>
        <content type="html"><![CDATA[<pre><code>public class StringBufferTest {
    public static void main(String[] args) {
	    String s1 = &quot;hello&quot;;
		String s2 = &quot;world&quot;;
    	System.out.println(s1 + &quot;---&quot; + s2);// hello---world
	    change(s1, s2);
		System.out.println(s1 + &quot;---&quot; + s2);// hello---world 

    	StringBuffer sb1 = new StringBuffer(&quot;hello&quot;);
	    StringBuffer sb2 = new StringBuffer(&quot;world&quot;);
    	System.out.println(sb1 + &quot;---&quot; + sb2);// hello---world
		change(sb1, sb2);
		System.out.println(sb1 + &quot;---&quot; + sb2);// hello---worldworld
	}

	public static void change(StringBuffer sb1, StringBuffer sb2) {
		sb1 = sb2;//引用的东西变了而已，main中的sb1引用没变
		sb2.append(sb1);
	}

    public static void change(String s1, String s2) {
	    s1 = s2;
	    s2 = s1 + s2;
    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java到底是值传递还是引用传递？]]></title>
        <id>https://zy080080.github.io//post/UYqd_tZ7B</id>
        <link href="https://zy080080.github.io//post/UYqd_tZ7B">
        </link>
        <updated>2019-09-12T05:49:39.000Z</updated>
        <summary type="html"><![CDATA[<p>原文作者：Intopass<br>
链接：<a href="https://www.zhihu.com/question/31203609/answer/50992895">https://www.zhihu.com/question/31203609/answer/50992895</a><br>
来源：知乎</p>
]]></summary>
        <content type="html"><![CDATA[<p>原文作者：Intopass<br>
链接：<a href="https://www.zhihu.com/question/31203609/answer/50992895">https://www.zhihu.com/question/31203609/answer/50992895</a><br>
来源：知乎</p>
 <!-- more --> 
<p><a href="https://zy080080.github.io/post/fFi1CAqNV/">Click here to read a related article in English</a></p>
<p> 首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还是传引用。这就好像用大学的名词来解释高中的题目，对于初学者根本没有任何意义。</p>
<h2 id="一搞清楚-基本类型-和-引用类型的不同之处">一：搞清楚 基本类型 和 引用类型的不同之处</h2>
<pre><code>int sun = 10;
String str = &quot;Hello&quot;;
</code></pre>
<p><img src="https://pic3.zhimg.com/80/166032bc90958c21604110441ad03f45_hd.jpg" alt=""><br>
 如图所示，num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为&quot;引用&quot;，引用指向实际对象，实际对象中保存着内容。</p>
<h2 id="二搞清楚赋值运算符的作用">二：搞清楚赋值运算符（=）的作用</h2>
<pre><code>num = 20;
str = &quot;java&quot;;
</code></pre>
<p><img src="https://pic4.zhimg.com/80/287c0efbb179638cf4cf27cbfdf3e746_hd.jpg" alt=""><br>
 对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。<br>
 对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。<mark><strong>但是原来的对象不会被改变（重要）</strong></mark>。如上图所示，&quot;hello&quot; 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）</p>
<h2 id="三调用方法时发生了什么参数传递基本上就是赋值操作">三：调用方法时发生了什么？<strong>参数传递基本上就是赋值操作</strong>。</h2>
<pre><code>第一个例子：基本类型
void foo(int value) {
    value = 100;
}
foo(num); // num 没有被改变

第二个例子：没有提供改变自身方法的引用类型
void foo(String text) {
    text = &quot;windows&quot;;
}
foo(str); // str 也没有被改变

第三个例子：提供了改变自身方法的引用类型
StringBuilder sb = new StringBuilder(&quot;iphone&quot;);
void foo(StringBuilder builder) {
    builder.append(&quot;4&quot;);
}
foo(sb); // sb 被改变了，变成了&quot;iphone4&quot;。

第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。
StringBuilder sb = new StringBuilder(&quot;iphone&quot;);
void foo(StringBuilder builder) {
    builder = new StringBuilder(&quot;ipad&quot;);
}
foo(sb); // sb 没有被改变，还是 &quot;iphone&quot;。
</code></pre>
<p> 重点理解为什么，第三个例子和第四个例子结果不同？</p>
<h3 id="下面是第三个例子的图解">下面是第三个例子的图解：</h3>
<figure data-type="image" tabindex="1"><img src="https://pic2.zhimg.com/80/d8b82e07ea21375ca6b300f9162aa95f_hd.jpg" alt=""></figure>
<p> builder.append(&quot;4&quot;)之后</p>
<figure data-type="image" tabindex="2"><img src="https://pic2.zhimg.com/80/ff2ede9c6c55568d42425561f25a0fd7_hd.jpg" alt=""></figure>
<h3 id="下面是第四个例子的图解">下面是第四个例子的图解：</h3>
<figure data-type="image" tabindex="3"><img src="https://pic2.zhimg.com/80/d8b82e07ea21375ca6b300f9162aa95f_hd.jpg" alt=""></figure>
<p> builder = new StringBuilder(&quot;ipad&quot;); 之后</p>
<figure data-type="image" tabindex="4"><img src="https://pic4.zhimg.com/80/46fa5f10cc135a3ca087dae35a5211bd_hd.jpg" alt=""></figure>
<hr>
<p>2018年1月31日添加部分内容：</p>
<h2 id="从局部变量方法参数开始讲起">从局部变量/方法参数开始讲起：</h2>
<p> 局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，随着进入方法开辟，退出方法回收。以32位JVM为例，boolean/byte/short/char/int/float以及引用都是分配4字节空间，long/double分配8字节空间。对于每个方法来说，最多占用多少空间是一定的，这在编译时就可以计算好。</p>
<p> 我们都知道JVM内存模型中有，stack和heap的存在，但是更准确的说，是每个线程都分配一个独享的stack，所有线程共享一个heap。对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更遑论修改。</p>
<p> 当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。</p>
<h2 id="数组类型引用和对象">数组类型引用和对象：</h2>
<p> 当我们声明一个数组时，如int[] arr = new int[10]，因为数组也是对象，arr实际上是引用，stack上仅仅占用4字节空间，new int[10]会在heap中开辟一个数组对象，然后arr指向它。</p>
<p> 当我们声明一个二维数组时，如 int[][] arr2 = new int[2][4]，arr2同样仅在stack中占用4个字节，会在内存中开辟一个长度为2的，类型为int[]的数组，然后arr2指向这个数组。这个数组内部有两个引用（大小为4字节），分别指向两个长度为4的类型为int的数组。</p>
<figure data-type="image" tabindex="5"><img src="https://pic4.zhimg.com/80/v2-6590cb935ae8bf3b7241cb309fe041d7_hd.jpg" alt=""></figure>
<p> 所以当我们传递一个数组引用给一个方法时，数组的元素是可以被改变的，但是无法让数组引用指向新的数组。</p>
<p> 你还可以这样声明：int[][] arr3 = new int[3][]，这时内存情况如下图</p>
<figure data-type="image" tabindex="6"><img src="https://pic2.zhimg.com/80/v2-fdc86227021d56a02b559d6485983c71_hd.jpg" alt=""></figure>
<p> 你还可以这样 arr3[0] = new int [5]; arr3[1] = arr2[0];</p>
<figure data-type="image" tabindex="7"><img src="https://pic1.zhimg.com/80/v2-fdc5e737a95d625a47d66ab61e4a2f55_hd.jpg" alt=""></figure>
<h2 id="关于string">关于String：</h2>
<p> 原本回答中关于String的图解是简化过的，实际上String对象内部仅需要维护三个变量，char[] chars, int startIndex, int length。而chars在某些情况下是可以共用的。但是因为String被设计成为了不可变类型，所以你思考时把String对象简化考虑也是可以的。</p>
<p> String str = new String(&quot;hello&quot;);</p>
<figure data-type="image" tabindex="8"><img src="https://pic4.zhimg.com/80/v2-a143d0a3594d06f54c6853c46c429e08_hd.jpg" alt=""></figure>
<p> 当然某些JVM实现会把&quot;hello&quot;字面量生成的String对象放到常量池中，而常量池中的对象可以实际分配在heap中，有些实现也许会分配在方法区，当然这对我们理解影响不大。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编语言相关指令英文全称]]></title>
        <id>https://zy080080.github.io//post/HbyyXGZL23</id>
        <link href="https://zy080080.github.io//post/HbyyXGZL23">
        </link>
        <updated>2019-09-11T08:41:55.000Z</updated>
        <content type="html"><![CDATA[<p>AH&amp;AL＝AX(accumulator)：累加寄存器<br>
BH&amp;BL＝BX(base)：基址寄存器<br>
CH&amp;CL＝CX(count)：计数寄存器<br>
DH&amp;DL＝DX(data)：数据寄存器<br>
SP（Stack Pointer）：堆栈指针寄存器<br>
BP（Base Pointer）：基址指针寄存器<br>
SI（Source Index）：源变址寄存器<br>
DI（Destination Index）：目的变址寄存器<br>
IP（Instruction Pointer）：指令指针寄存器<br>
CS（Code Segment）代码段寄存器<br>
DS（Data Segment）：数据段寄存器<br>
SS（Stack Segment）：堆栈段寄存器<br>
ES（Extra Segment）：附加段寄存器<br>
OF overflow flag 溢出标志 操作数超出机器能表示的范围表示溢出,溢出时为1.<br>
SF sign Flag 符号标志 记录运算结果的符号,结果负时为1.<br>
ZF zero flag 零标志 运算结果等于0时为1,否则为0.<br>
CF carry flag 进位标志 最高有效位产生进位时为1,否则为0.<br>
AF auxiliary carry flag 辅助进位标志 运算时,第3位向第4位产生进位时为1,否则为0.<br>
PF parity flag 奇偶标志 运算结果操作数位为1的个数为偶数个时为1,否则为0.<br>
DF direcion flag 方向标志 用于串处理.DF=1时,每次操作后使SI和DI减小.DF=0时则增大.<br>
IF interrupt flag 中断标志 IF=1时,允许CPU响应可屏蔽中断,否则关闭中断.<br>
TF trap flag 陷阱标志 用于调试单步操作.</p>
<h3 id="1通用数据传送指令">1.通用数据传送指令</h3>
<p>MOV----&gt; move<br>
MOV dest,src ;dest←src<br>
MOV指令把一个字节或字的操作数从源地址src传送至目的地址dest。</p>
<p>MOVSX----&gt;extended move with sign data<br>
MOVZX----&gt;extended move with zero data<br>
PUSH----&gt;push<br>
POP----&gt;pop<br>
进栈出栈指令<br>
PUSHA----&gt;push all<br>
POPA----&gt;pop all<br>
PUSHAD----&gt;push all data<br>
POPAD----&gt;pop all data<br>
BSWAP----&gt;byte swap<br>
XCHG----&gt;exchange<br>
交换指令用来将源操作数和目的操作数内容交换，操作数可以是字、也可以是字节，可以在通用寄存器与通用寄存器或存储器之间对换数据，但不能在存储器与存储器之间对换数据。<br>
mov ax,1234h ;ax=1234h<br>
mov bx,5678h ;bx=5678h<br>
xchg ax,bx ;ax=5678h，bx=1234h<br>
xchg ah,al ;ax=7856h</p>
<p>CMPXCHG----&gt;compare and change<br>
XADD----&gt;exchange and add</p>
<p>XLAT----&gt;translate<br>
换码指令用于将BX指定的缓冲区中、AL指定的位移处的数据取出赋给AL。</p>
<h3 id="2输入输出端口传送指令">2.输入输出端口传送指令</h3>
<p>IN----&gt;input<br>
OUT----&gt;output</p>
<h3 id="3目的地址传送指令">3.目的地址传送指令</h3>
<p>LEA----&gt;load effective addres<br>
有效地址传送指令<br>
mov bx,0400h<br>
mov si,3ch<br>
lea bx,[bx+si+0f62h] ;BX=139EH<br>
这里BX得到的是主存单元的有效地址，不是物理地址，也不是该单元的内容。<br>
LDS----&gt;load DS<br>
LES----&gt;load ES<br>
LFS----&gt;load FS<br>
LGS----&gt;load GS<br>
LSS----&gt;load SS</p>
<h3 id="4标志传送指令">4.标志传送指令</h3>
<p>LAHF----&gt;load AH from flag<br>
SAHF----&gt;save AH to flag<br>
PUSHF----&gt;push flag<br>
POPF----&gt;pop flag<br>
PUSHD----&gt;push dflag<br>
POPD----&gt;pop dflag</p>
<h2 id="二-算术运算指令">二、算术运算指令</h2>
<p>ADD----&gt;add<br>
加法指令 mov al,0fbh ;al=0fbh<br>
add al,07h ;al=02h<br>
ADC----&gt;add with carry<br>
INC----&gt;increase 1<br>
AAA----&gt;ascii add with adjust<br>
DAA----&gt;decimal add with adjust<br>
SUB----&gt;substract<br>
SBB----&gt;substract with borrow<br>
DEC----&gt;decrease 1<br>
NEC----&gt;negative<br>
CMP----&gt;compare<br>
AAS----&gt;ascii adjust on substract<br>
DAS----&gt;decimal adjust on substract<br>
MUL----&gt;multiplication<br>
IMUL----&gt;integer multiplication<br>
AAM----&gt;ascii adjust on multiplication<br>
DIV----&gt;divide<br>
IDIV----&gt;integer divide<br>
AAD----&gt;ascii adjust on divide<br>
CBW----&gt;change byte to word<br>
CWD----&gt;change word to double word<br>
CWDE----&gt;change word to double word with sign to EAX<br>
CDQ----&gt;change double word to quadrate word</p>
<h2 id="三-逻辑运算指令">三、逻辑运算指令</h2>
<p>AND----&gt;and<br>
or----&gt;or<br>
XOR----&gt;xor<br>
NOT----&gt;not<br>
TEST----&gt;test<br>
SHL----&gt;shift left<br>
SAL----&gt;arithmatic shift left<br>
SHR----&gt;shift right<br>
SAR----&gt;arithmatic shift right<br>
ROL----&gt;rotate left<br>
ROR----&gt;rotate right<br>
RCL----&gt;rotate left with carry<br>
RCR----&gt;rotate right with carry</p>
<h2 id="四-串指令">四、串指令</h2>
<p>MOVS----&gt;move string<br>
CMPS----&gt;compare string<br>
SCAS----&gt;scan string<br>
LODS----&gt;load string<br>
STOS----&gt;store string<br>
REP----&gt;repeat<br>
REPE----&gt;repeat when equal<br>
REPZ----&gt;repeat when zero flag<br>
REPNE----&gt;repeat when not equal<br>
REPNZ----&gt;repeat when zero flag<br>
REPC----&gt;repeat when carry flag<br>
REPNC----&gt;repeat when not carry flag</p>
<h2 id="五-程序转移指令">五、程序转移指令</h2>
<p>1&gt;无条件转移指令(长转移)</p>
<p>JMP----&gt;jump<br>
CALL----&gt;call<br>
RET----&gt;return<br>
RETF----&gt;return far</p>
<p>2&gt;条件转移指令(短转移,-128到+127的距离内)</p>
<p>JAE----&gt;jump when above or equal<br>
JNB----&gt;jump when not below<br>
JB----&gt;jump when below<br>
JNAE----&gt;jump when not above or equal<br>
JBE----&gt;jump when below or equal<br>
JNA----&gt;jump when not above<br>
JG----&gt;jump when greater<br>
JNLE----&gt;jump when not less or equal<br>
JGE----&gt;jump when greater or equal<br>
JNL----&gt;jump when not less<br>
JL----&gt;jump when less<br>
JNGE----&gt;jump when not greater or equal<br>
JLE----&gt;jump when less or equal<br>
JNG----&gt;jump when not greater<br>
JE----&gt;jump when equal<br>
JZ----&gt;jump when has zero flag<br>
JNE----&gt;jump when not equal<br>
JNZ----&gt;jump when not has zero flag<br>
JC----&gt;jump when has carry flag<br>
JNC----&gt;jump when not has carry flag<br>
JNO----&gt;jump when not has overflow flag<br>
JNP----&gt;jump when not has parity flag<br>
JPO----&gt;jump when parity flag is odd<br>
JNS----&gt;jump when not has sign flag<br>
JO----&gt;jump when has overflow flag<br>
JP----&gt;jump when has parity flag<br>
JPE----&gt;jump when parity flag is even<br>
JS----&gt;jump when has sign flag</p>
<p>3&gt;循环控制指令(短转移)</p>
<p>LOOP----&gt;loop<br>
LOOPE----&gt;loop equal<br>
LOOPZ----&gt;loop zero<br>
LOOPNE----&gt;loop not equal<br>
LOOPNZ----&gt;loop not zero<br>
JCXZ----&gt;jump when CX is zero<br>
JECXZ----&gt;jump when ECX is zero</p>
<p>4&gt;中断指令</p>
<p>INT----&gt;interrupt<br>
INTO----&gt;overflow interrupt<br>
IRET----&gt;interrupt return</p>
<p>5&gt;处理器控制指令</p>
<p>HLT----&gt;halt<br>
WAIT----&gt;wait<br>
ESC----&gt;escape<br>
LOCK----&gt;lock<br>
NOP----&gt;no operation<br>
STC----&gt;set carry<br>
CLC----&gt;clear carry<br>
CMC----&gt;carry make change<br>
STD----&gt;set direction<br>
CLD----&gt;clear direction<br>
STI----&gt;set interrupt<br>
CLI----&gt;clear interrupt</p>
<h2 id="六-伪指令">六、伪指令</h2>
<p>DW----&gt;definw word<br>
PROC----&gt;procedure<br>
ENDP----&gt;end of procedure<br>
SEGMENT----&gt;segment<br>
ASSUME----&gt;assume<br>
ENDS----&gt;end segment<br>
END----&gt;end</p>
<h1 id="汇编指令中文释义">汇编指令中文释义</h1>
<h2 id="1数据传输指令">1.数据传输指令</h2>
<p>它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.</p>
<ol>
<li>通用数据传送指令.<br>
MOV 传送字或字节.<br>
MOVSX 先符号扩展,再传送.<br>
MOVZX 先零扩展,再传送.<br>
PUSH 把字压入堆栈.<br>
POP 把字弹出堆栈.<br>
PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.<br>
POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.<br>
PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.<br>
POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.<br>
BSWAP 交换32位寄存器里字节的顺序<br>
XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)<br>
CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX )<br>
XADD 先交换再累加.( 结果在第一个操作数里 )<br>
XLAT 字节查表转换.<br>
── BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即<br>
0-FFH); 返回 AL 为查表结果. ( [BX+AL]-&gt;AL )</li>
<li>输入输出端口传送指令.<br>
IN I/O端口输入. ( 语法: IN 累加器, {端口号│DX} )<br>
OUT I/O端口输出. ( 语法: OUT {端口号│DX},累加器 )<br>
输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,<br>
其范围是 0-65535.</li>
<li>目的地址传送指令.<br>
LEA 装入有效地址.<br>
例: LEA DX,string ;把偏移地址存到DX.<br>
LDS 传送目标指针,把指针内容装入DS.<br>
例: LDS SI,string ;把段地址:偏移地址存到DS:SI.<br>
LES 传送目标指针,把指针内容装入ES.<br>
例: LES DI,string ;把段地址:偏移地址存到ES:DI.<br>
LFS 传送目标指针,把指针内容装入FS.<br>
例: LFS DI,string ;把段地址:偏移地址存到FS:DI.<br>
LGS 传送目标指针,把指针内容装入GS.<br>
例: LGS DI,string ;把段地址:偏移地址存到GS:DI.<br>
LSS 传送目标指针,把指针内容装入SS.<br>
例: LSS DI,string ;把段地址:偏移地址存到SS:DI.</li>
<li>标志传送指令.<br>
LAHF 标志寄存器传送,把标志装入AH.<br>
SAHF 标志寄存器传送,把AH内容装入标志寄存器.<br>
PUSHF 标志入栈.<br>
POPF 标志出栈.<br>
PUSHD 32位标志入栈.<br>
POPD 32位标志出栈.</li>
</ol>
<h2 id="二-算术运算指令-2">二、算术运算指令</h2>
<p>───────────────────────────────────────<br>
ADD 加法.<br>
ADC 带进位加法.<br>
INC 加 1.<br>
AAA 加法的ASCII码调整.<br>
DAA 加法的十进制调整.<br>
SUB 减法.<br>
SBB 带借位减法.<br>
DEC 减 1.<br>
NEC 求反(以 0 减之).<br>
CMP 比较.(两操作数作减法,仅修改标志位,不回送结果).<br>
AAS 减法的ASCII码调整.<br>
DAS 减法的十进制调整.<br>
MUL 无符号乘法.<br>
IMUL 整数乘法.<br>
以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算),<br>
AAM 乘法的ASCII码调整.<br>
DIV 无符号除法.<br>
IDIV 整数除法.<br>
以上两条,结果回送:<br>
商回送AL,余数回送AH, (字节运算);<br>
或 商回送AX,余数回送DX, (字运算).<br>
AAD 除法的ASCII码调整.<br>
CBW 字节转换为字. (把AL中字节的符号扩展到AH中去)<br>
CWD 字转换为双字. (把AX中的字的符号扩展到DX中去)<br>
CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去)<br>
CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去)</p>
<h2 id="三-逻辑运算指令-2">三、逻辑运算指令</h2>
<p>───────────────────────────────────────<br>
AND 与运算.<br>
or 或运算.<br>
XOR 异或运算.<br>
NOT 取反.<br>
TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果).<br>
SHL 逻辑左移.<br>
SAL 算术左移.(=SHL)<br>
SHR 逻辑右移.<br>
SAR 算术右移.(=SHR) 当值为负时，高位补 1 ；当值为正时，高位补 0<br>
ROL 循环左移.<br>
ROR 循环右移.<br>
RCL 通过进位的循环左移.<br>
RCR 通过进位的循环右移.<br>
以上八种移位指令,其移位次数可达255次.<br>
移位一次时, 可直接用操作码. 如 SHL AX,1.<br>
移位&gt;1次时, 则由寄存器CL给出移位次数.<br>
如 MOV CL,04<br>
SHL AX,CL</p>
<h2 id="四-串指令-2">四、串指令</h2>
<p>───────────────────────────────────────<br>
DS:SI 源串段寄存器 :源串变址.<br>
ES:DI 目标串段寄存器:目标串变址.<br>
CX 重复次数计数器.<br>
AL/AX 扫描值.<br>
D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量.<br>
Z标志 用来控制扫描或比较操作的结束.<br>
MOVS 串传送.<br>
( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )<br>
CMPS 串比较.<br>
( CMPSB 比较字符. CMPSW 比较字. )<br>
SCAS 串扫描.<br>
把AL或AX的内容与目标串作比较,比较结果反映在标志位.<br>
LODS 装入串.<br>
把源串中的元素(字或字节)逐一装入AL或AX中.<br>
( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )<br>
STOS 保存串.<br>
是LODS的逆过程.<br>
REP 当CX/ECX&lt;&gt;0时重复.<br>
REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复.<br>
REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复.<br>
REPC 当CF=1且CX/ECX&lt;&gt;0时重复.<br>
REPNC 当CF=0且CX/ECX&lt;&gt;0时重复.</p>
<h2 id="五-程序转移指令-2">五、程序转移指令</h2>
<p>───────────────────────────────────────<br>
1&gt;无条件转移指令 (长转移)<br>
JMP 无条件转移指令<br>
CALL 过程调用<br>
RET/RETF过程返回.<br>
2&gt;条件转移指令 (短转移,-128到+127的距离内)<br>
( 当且仅当(SF XOR OF)=1时,OP1 JA/JNBE 不小于或不等于时转移.<br>
JAE/JNB 大于或等于转移.<br>
JB/JNAE 小于转移.<br>
JBE/JNA 小于或等于转移.<br>
以上四条,测试无符号整数运算的结果(标志C和Z).<br>
JG/JNLE 大于转移.<br>
JGE/JNL 大于或等于转移.<br>
JL/JNGE 小于转移.<br>
JLE/JNG 小于或等于转移.<br>
以上四条,测试带符号整数运算的结果(标志S,O和Z).<br>
JE/JZ 等于转移.<br>
JNE/JNZ 不等于时转移.<br>
JC 有进位时转移.<br>
JNC 无进位时转移.<br>
JNO 不溢出时转移.<br>
JNP/JPO 奇偶性为奇数时转移.<br>
JNS 符号位为 &quot;0&quot; 时转移.<br>
JO 溢出转移.<br>
JP/JPE 奇偶性为偶数时转移.<br>
JS 符号位为 &quot;1&quot; 时转移.<br>
3&gt;循环控制指令(短转移)<br>
LOOP CX不为零时循环.<br>
LOOPE/LOOPZ CX不为零且标志Z=1时循环.<br>
LOOPNE/LOOPNZ CX不为零且标志Z=0时循环.<br>
JCXZ CX为零时转移.<br>
JECXZ ECX为零时转移.<br>
4&gt;中断指令<br>
INT 中断指令<br>
INTO 溢出中断<br>
IRET 中断返回<br>
5&gt;处理器控制指令<br>
HLT 处理器暂停, 直到出现中断或复位信号才继续.<br>
WAIT 当芯片引线TEST为高电平时使CPU进入等待状态.<br>
ESC 转换到外处理器.<br>
LOCK 封锁总线.<br>
NOP 空操作.<br>
STC 置进位标志位.<br>
CLC 清进位标志位.<br>
CMC 进位标志取反.<br>
STD 置方向标志位.<br>
CLD 清方向标志位.<br>
STI 置中断允许位.<br>
CLI 清中断允许位.</p>
<h2 id="六-伪指令-2">六、伪指令</h2>
<p>─────────────────────────────────────<br>
DW 定义字(2字节).<br>
PROC 定义过程.<br>
ENDP 过程结束.<br>
SEGMENT 定义段.<br>
ASSUME 建立段寄存器寻址.<br>
ENDS 段结束.<br>
END 程序结束.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编语言笔记（第二章）]]></title>
        <id>https://zy080080.github.io//post/HbYYbk2Z</id>
        <link href="https://zy080080.github.io//post/HbYYbk2Z">
        </link>
        <updated>2019-09-10T11:07:01.000Z</updated>
        <summary type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
]]></summary>
        <content type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
<!-- more -->
<h1 id="第二章-寄存器">第二章 寄存器</h1>
<p> 一个典型的CPU由运算器、控制器、寄存器（CPU工作原理）等器件构成，这些器件靠内部总线相连，前一章的总栈相对于CPU内部来说是外部总线。内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其他器件的联系。在CPU中：</p>
<ul>
<li>运算器进行信息处理；</li>
<li>寄存器进行信息储存；</li>
<li>控制器控制各种器件进行工作；</li>
<li>内部总栈链接各种器件，在他们之间进行数据的传送。</li>
</ul>
<p> 对于一个汇编程序员来说，CPU中的主要部件是寄存器。寄存器是CPU中程序员可以用指令读写的部件。通过改变各种寄存器中的内容来实现对CPU的控制。</p>
<h2 id="21-通用寄存器">2.1 通用寄存器</h2>
<p> 8086CPU的所有寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这四个寄存器通常用来存放一般性的数据，被称为通用寄存器。<br>
 8086CPU的上一代CPU中的寄存器都是8位的，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在8086上，8086CPU的AX、BX、CX、DX这四个寄存器都可以分为两个可独立使用的8位寄存器来用：</p>
<ul>
<li>AX可分为AH和AL；</li>
<li>BX可分为BH和BL；</li>
<li>CX可分为CH和CL；</li>
<li>DX可分为DH和DL。</li>
</ul>
<p> AX的低8位（0位<sub>7位）构成了AL寄存器，高8位（8位</sub>15位）构成了AH寄存器。</p>
<blockquote>
<p>图例见教材P15。</p>
</blockquote>
<h2 id="22-字在寄存器中的储存">2.2 字在寄存器中的储存</h2>
<p> 出于对兼容性的考虑，8086CPU可以一次性处理一下两种尺寸的数据：</p>
<ul>
<li>字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。</li>
<li>字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">01001110</th>
<th style="text-align:center">00100000</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">高位字节</td>
<td style="text-align:center">低位字节</td>
</tr>
</tbody>
</table>
<h2 id="23-几条汇编指令">2.3 几条汇编指令</h2>
<table>
<thead>
<tr>
<th style="text-align:left">汇编指令</th>
<th style="text-align:left">控制CPU完成的操作</th>
<th style="text-align:left">用高级语言的语法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">mov ax,18</td>
<td style="text-align:left">将18送入寄存器AX</td>
<td style="text-align:left">AX=18</td>
</tr>
<tr>
<td style="text-align:left">mov ah,78</td>
<td style="text-align:left">将78送入寄存器AH</td>
<td style="text-align:left">AH=78</td>
</tr>
<tr>
<td style="text-align:left">add ax,8</td>
<td style="text-align:left">将寄存器AX中的数值加上8</td>
<td style="text-align:left">AX=AX+8</td>
</tr>
<tr>
<td style="text-align:left">mov ax,bx</td>
<td style="text-align:left">将寄存器BX中的数据送入寄存器AX</td>
<td style="text-align:left">AX=BX</td>
</tr>
<tr>
<td style="text-align:left">add ax bx</td>
<td style="text-align:left">将AX和BX中的数值相加，结果存在AX中</td>
<td style="text-align:left">AX=AX+BX</td>
</tr>
</tbody>
</table>
<h2 id="24-物理地址">2.4 物理地址</h2>
<p> CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的储存空间是一个一维的线性空间，每一个内存单元在这个空间都有唯一的地址，我们将其称为物理地址。<br>
 CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU有不同的形成物理地址的方式。在此我们讨论8086CPU。</p>
<h2 id="25-16位结构的cpu">2.5 16位结构的CPU</h2>
<p> 概括地讲，16位结构（16位机，字长为16位等常见说法，与16位结构的含义相同）描述了一个CPU具有下面几方面的结构特性。</p>
<ul>
<li>运算器一次最多可处理16位的数据；</li>
<li>寄存器的最大宽度位16位；</li>
<li>寄存器和运算器之间的通路位16位。<br>
 8086是16位结构的CPU，也就是说，在8086内部，能够一次性处理、传输、暂时储存的信息的最大长度是16位的。内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次性处理、传输、暂时存储16位的地址。</li>
</ul>
<h2 id="26-8086cpu给出物理地址的方法">2.6 8086CPU给出物理地址的方法</h2>
<p> 8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理、船速、暂时储存的地址为16位。从8086CPU的内部结构来看，如果将地址从内部简单的发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。<br>
 8086CPU采用一中在内部用两个16位地址合成的方法来形成一个20位的物理地址。当8086CPU要读写内存时：</p>
<ol>
<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；</li>
<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；</li>
<li>地址加法器将两个16位地址合成为一个20位的物理地址；</li>
<li>地址加法器通过<mark>内部总线</mark>将20位物理地址送入输入输出控制电路；</li>
<li>输入输出控制电路将20位物理地址送上地址总线；</li>
<li>20位物理地址被地址总线传送到存储器（内存）。</li>
</ol>
<p> 地址加法器采用<strong>物理地址=段地址x16+偏移地址</strong>的方式用段地址和偏移地址合成物理地址。</p>
<blockquote>
<h3 id="由-段地址x16-引发的讨论">由 段地址x16 引发的讨论</h3>
<p> “段地址x16”有一个更为常用的说法是左移4位。计算机中的所有信息都是以二进制的形式存储的，段地址也不例外。机器智能处理而禁止信息，”左移4位“中的位，指的是二进制位<br>
 一个X进制的数据左移1位，相当于乘以X。</p>
</blockquote>
<h2 id="27-段地址x16偏移地址物理地址的本质含义">2.7 “段地址x16+偏移地址=物理地址”的本质含义</h2>
<p> “段地址x16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地质（段地址x16）和一个相对与基础地址的偏移地址相加，给出内存单元的物理地址。<br>
 更一般地说，8086CPU这种寻址功能是“基础地质+偏移地址=-物理地址”寻址模式的一种具体实现方案。<br>
 下面比喻说明。<br>
 比如说，学校、体育馆、图书馆在一条笔直的单行路上，学校位于路的起点。</p>
<table>
<thead>
<tr>
<th>学校</th>
<th>-2 0 0 0 米-</th>
<th>体育馆</th>
<th>-8 2 6 米-</th>
<th>图书馆</th>
</tr>
</thead>
<tbody>
<tr>
<td>0米</td>
<td>----------→</td>
<td>2000米</td>
<td>----------→</td>
<td>2826米</td>
</tr>
</tbody>
</table>
<p> 你要去图书馆，问我那里的地址，我可以用两种方式告诉你图书馆的地址：</p>
<ol>
<li>从学校走2826m到图书馆。这2826m可以认为是图书馆的物理地址。</li>
<li>从学校走2000m到体育馆，从体育馆再走826m到图书馆。第一个距离2000m是相当于起点的基础地址，第二个距离826m是相对于基础地址的偏移地址（以基础地址为起点的地址）。</li>
</ol>
<p> 第一种方式直接给出物理地址2826m，第二种方式使用基础地址和偏移地址相加来得到物理地址的。<br>
 我们为上面的例子加一些限制条件，比如只能通过纸条来互相通信，如果我有一张可以容纳4位数据的纸条，我可以写下2826这个数据。</p>
<table>
<thead>
<tr>
<th>2</th>
<th>8</th>
<th>2</th>
<th>6</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p> 可不巧的是我仅有两张可以容纳三位数据的纸条。这样我只能通过这总方式来传达数据。</p>
<table>
<thead>
<tr>
<th>2</th>
<th>0</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>2</td>
<td>6</td>
</tr>
</tbody>
</table>
<p> 假设我们事先约定，得到两张之后做这样的运算：</p>
<ul>
<li>200（段地址）x10 + 826（偏移地址） = 2826（物理地址）</li>
</ul>
<h2 id="28-段的概念">2.8 段的概念</h2>
<p> 内存并没有分段，段的划分来自于CPU，由于8086CPU用“基础地质+偏移地址=-物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。<br>
 在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址x16的起始地址（基础地址），用偏移地址定位段中的内存单元。</p>
<blockquote>
<h3 id="内存单元地址小结">内存单元地址小结</h3>
<p> CPU可以用不同的段地址和偏移地址形成同一个物理地址。</p>
<ul>
<li>例如CPU要访问21F60H单元，则它给出的段地址SA和偏移地址EA满足SAx16+EA=21F60H即可。</li>
</ul>
<p> 偏移地址16位，变化范围为0~FFFFH，仅用偏移地址来寻址最多可寻64KB个内存单元。</p>
<ul>
<li>比如给定段地址1000H，用偏移地址寻址，CPU的寻址范围为：10000H~1FFFFH。</li>
</ul>
<p> “数据在21F60H中。”这句话对于8086CPU机一般不这样讲，取而代之的是两种类似的说法：</p>
<ol>
<li>数据存在内存 2000:1F60 中；</li>
<li>数据存在内存的2000H段中的1F60H单元中。</li>
</ol>
</blockquote>
<blockquote>
<h3 id="检测点22">检测点2.2</h3>
<p> 有一数据存放在内存20000H单元中，现给定段地址位SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为（1001H），最大为（2000H）。</p>
<blockquote>
<p>网上给出的解析：20000H - FFFFH/10H = 2000H - 0FFFH = 1001H</p>
</blockquote>
<blockquote>
<p>个人思考：20000H - FFFFH = 10001H，右移一位成为1000H，但是不够的，所以最小应为1001H。</p>
</blockquote>
</blockquote>
<h2 id="29-段存器">2.9 段存器</h2>
<p>​ 段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。本章只看一下CS。</p>
<h2 id="210-cs和ip">2.10 CS和IP</h2>
<p> CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前尧都区指令的地址。CS为代码段寄存器，IP位指令指针寄存器。<br>
 8086机中，任意时刻，CPU将 CS:IP 指向的内容当做指令执行。</p>
<blockquote>
<p>图解看书P26。</p>
</blockquote>
<p> 在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，CPU从内存 FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。<br>
 在任何时候，CPU将CS、IP中的内容当做指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。如果说，内存中的一段信息曾被CPU执行过的话，那么，他所在的内存单元必然被 CS:IP 指向过。</p>
<h2 id="211-修改cs-ip的指令">2.11 修改CS、IP的指令</h2>
<p> 在CPU中，程序员能够用指令修改的部件只有寄存器，可以通过改变CS、IP中的内容来控制CPU执行目标指令。<br>
 jmp指令</p>
<ul>
<li>若想同时修改CS、IP的内容，可用形如“jmp 段地址：偏移地址”的指令完成，如
<ul>
<li>jmp 2AE3:3，执行后： CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令。</li>
</ul>
</li>
<li>若只想修改IP的内容，可用形如“jmp 某一合法寄存器”的指令完成，如：
<ul>
<li>jmp ax<br>
指令执行前：ax=1000H, CS=2000H, IP=0003H<br>
执行后：ax=1000H, CS=2000H, IP=1000H</li>
</ul>
</li>
</ul>
<p> jmp ax，在含义上好似： mov IP,ax。</p>
<blockquote>
<h3 id="检测点23">检测点2.3</h3>
<p>下面的三条指令执行后，CPU几次修改IP？都是在什么时候？最后IP中的值是多少？<br>
(1) mov ax,bx<br>
(2) sub ax,ax<br>
(3) jmp ax</p>
<p>答案：四次</p>
<ul>
<li>第一次：(1)执行前</li>
<li>第二次：(2)执行前</li>
<li>第三次：(3)执行前</li>
<li>第四次：jmp指令执行后，IP变为0</li>
</ul>
<p>注：指令在被传到指令缓冲器，被执行前IP自动指向下一指令。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The way to make sure never to draw a number twice]]></title>
        <id>https://zy080080.github.io//post/AsProG7</id>
        <link href="https://zy080080.github.io//post/AsProG7">
        </link>
        <updated>2019-09-09T18:02:54.000Z</updated>
        <summary type="html"><![CDATA[<p> When we draw k numbers from numbers[n], how to be sure never to draw a number again?</p>
]]></summary>
        <content type="html"><![CDATA[<p> When we draw k numbers from numbers[n], how to be sure never to draw a number again?</p>
 <!-- more --> 
<p> This program draws a random combination of numbers for a lottery game.<br>
 The way to draw a number just once is :</p>
<blockquote>
<p> To overwrite numbers[r] with the last number in the array and reduce n by 1.</p>
</blockquote>
<p> 将原本number[r]的元素移除后，通过n每次的缩小随机数产生的范围避免重复。</p>
<pre><code>import java.util.*;

public class LotteryDrawing {
	public static void main (String[] args) {
		Scanner in = new Scanner(System.in);
	
		System.out.print(&quot;How many numbers do you need to draw? &quot;);
		int k = in.nextInt();
	
		System.out.print(&quot;What is the highest numbers you can draw? &quot;);
		int n = in.nextInt();
	
		//fill an arry with numbers 1 2 3. . .n
		int[] numbers = new int[n];
		for(int i = 0; i &lt; numbers.length; i++) {
			numbers[i] = i + 1;
		}
		
		//draw k numbers and put them into a second array
		int[] result = new int[k];
		for(int i = 0; i &lt; result.length; i++) {
			//make a random index between 0 and n - 1
			int r = (int)(Math.random() * n);
			
			//pick the element at the random location
			result[i] = numbers[r];
			
			//move the last element into the random location
			numbers[r] = numbers[n - 1];
			n--;
		}
	
		//print the sorted array
		Arrays.sort(result);
		System.out.println(&quot;Bet the following combination. It'll make you rich!&quot;);
		for(int r : result) {
			System.out.print(r + &quot; &quot;);
		}
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编语言笔记（第一章）]]></title>
        <id>https://zy080080.github.io//post/HBYybJD1Z</id>
        <link href="https://zy080080.github.io//post/HBYybJD1Z">
        </link>
        <updated>2019-09-09T05:28:56.000Z</updated>
        <summary type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
]]></summary>
        <content type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
<!-- more -->
<h1 id="第一章">第一章</h1>
<h2 id="1基础知识">1.基础知识</h2>
<h3 id="11-机器语言">1.1 机器语言</h3>
<ul>
<li>电子计算机的机器指令是一列二进制数字。计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算。</li>
<li>现在我们常用的PC机中，有一个芯片来完成上面所说的计算机的功能。这个芯片是CPU（Central Processing Unit），是一种微型处理器。</li>
</ul>
<h3 id="14-储存器">1.4 储存器</h3>
<ul>
<li>要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在储存器中存放，也就是我们平时所说的内存。</li>
<li>磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被CPU使用。</li>
</ul>
<h3 id="16-储存单元">1.6 储存单元</h3>
<ul>
<li>储存器被划分成若干个储存单元，每个储存单元从0开始顺序编号，例如一个储存器有128个储存单元，编号从0~127。</li>
<li><strong>微型机储存器的储存单元可以储存一个Byte</strong>，即8个二进制单位（bit）。一个储存器有128个储存单元，它可以储存128个Byte。</li>
<li>微机储存器的容量是以字节为最小单位来计算的。对于拥有128个储存单元的储存器，我们可以说，它的容量是128个字节。</li>
</ul>
<h3 id="17-cpu对储存器的读写">1.7 CPU对储存器的读写</h3>
<ul>
<li>CPU想要进行数据的读写，必须和外部器件（标准的说法是芯片）进行下面三类信息的交互。
<ul>
<li>储存单元的地址（地址信息）。</li>
<li>器件的选择，读说写的命令（控制信息）。</li>
<li>读或写的数据（数据信息）。</li>
</ul>
</li>
<li>地址总线、数据总线和控制总线。
<ul>
<li>地址总线的宽度决定了CPU的寻地址能力，一个CPU有N根地址总线，则可以说这个CPU的地址总线跨度为N。这样的CPU最多可以寻找2的N次方个内存单元。</li>
<li>数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量，决定了CPU和外接的数据传送速度。8根数据总线一次可以传送一个8位二进制数据（即一个字节）。16根数据总线一次可以传送两个字节。</li>
<li>控制总线的宽度决定了CPU对系统中其他器件的控制能力。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="检测点11">检测点1.1</h4>
<p>1个CPU的寻地址能力是8KB，那么他的地址总线的宽度为<u>13</u>。（以二为底的log(8*1024)）<br>
可寻址2^10个内存单元 = 2^10 Byte内存单元。<br>
2^20 个不同的数据 = (2^20)/1024 = 1024KB 不同数据 = 1MB不同数据。</p>
</blockquote>
<h3 id="114-各类储存器芯片">1.14 各类储存器芯片</h3>
<ul>
<li>随机储存器（RAM），可读可写但必须带电储存，关机后储存的内容消失。<br>
用于存放供CPU使用的决大份程序个数据，主随机储存器一般由两个位置上的RAM组成，装在主板上的RAM和插在扩展插槽上的RAM。</li>
<li>装有BIOS（Basic Input/Output System，基本输入/输出系统）的ROM。<br>
BIOS是由主板和各类接口卡（显卡网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。<br>
在主板和某些接口卡上插有储存相应BIOS的ROM。例如，主板上的ROM中分储存着主板的BIOS（通常称为系统BIOS）；显卡上的ROM中储存着显卡的BIOS。</li>
<li>接口卡上的RAM。<br>
某些接口卡需要对大批量输入、输出数据进行暂时储存，在其上装有RAM。最典型的是显示卡上的RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。</li>
</ul>
<h3 id="115-内存地址空间">1.15 内存地址空间</h3>
<p> 上述的那些储存器，在物理上是独立的器件，但是在以下两点上相同：</p>
<ul>
<li>都和CPU的总线相连。</li>
<li>CPU对他们进行读或写的时候都通过控制总线发出内存读写命令。</li>
</ul>
<p> 所有的物理储存器被看作一个由若干储存单元组成的逻辑储存器，每个物理储存器在这个逻辑储存器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理储存器中读写数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java time !]]></title>
        <id>https://zy080080.github.io//post/java-time</id>
        <link href="https://zy080080.github.io//post/java-time">
        </link>
        <updated>2019-08-23T17:21:07.000Z</updated>
        <summary type="html"><![CDATA[<p>  It's time to learn something in English.</p>
]]></summary>
        <content type="html"><![CDATA[<p>  It's time to learn something in English.</p>
<!-- more --> 
<p>  These days, I'm learning Java by watching videoes. Though I'd been learning Java for half a year, but meanwhile I was preparing my college entrance exam. so I could not concentrate on programming. I think it is necessary to have a review because in next term I'm going to attend Java class which is taught in Japanese.<br>
  It's kind of a difficult stuff that learning something in three languages. I'm trying to review what I have learned by using a book called 'Head First Java', the English version.</p>
<hr>
<br>
<p><img src="https://zy080080.github.io//post-images/1566570199123.png" alt=""><br>
 整个暑假都在折腾英语和Java了....最近打算把汇编的书看一看，提前预习免得下学期忙不过来</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[My First Personal Blog]]></title>
        <id>https://zy080080.github.io//post/my-first-personal-blog</id>
        <link href="https://zy080080.github.io//post/my-first-personal-blog">
        </link>
        <updated>2019-08-22T11:06:53.000Z</updated>
        <summary type="html"><![CDATA[<p> I watched a video on bilibili in which the author suggests that people who want to work at an IT company should start a blog. So I took whole day to figure out how to create a blog in github.</p>
]]></summary>
        <content type="html"><![CDATA[<p> I watched a video on bilibili in which the author suggests that people who want to work at an IT company should start a blog. So I took whole day to figure out how to create a blog in github.</p>
<!-- more --> 
<p> This is the first article I have written to celebrate the opening of my personal blog which at last ran successfully in 20190821. I'm going to use it as a technology blog and put any note on it which is important in programming or anything else computer involved.<br>
 I'll try my best to write articles in English. I hope this is a good challenge and a good chance to prove my proficiency in English.<br>
 Never Stop Learning.<br>
 厚积薄发。</p>
]]></content>
    </entry>
</feed>