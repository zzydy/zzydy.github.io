<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy080080.github.io/</id>
    <title>听故事的人</title>
    <updated>2020-03-19T12:49:04.946Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy080080.github.io/"/>
    <link rel="self" href="https://zy080080.github.io/atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://zy080080.github.io/images/avatar.png</logo>
    <icon>https://zy080080.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 听故事的人</rights>
    <entry>
        <title type="html"><![CDATA[Java基礎まとめ]]></title>
        <id>https://zy080080.github.io/post/XECKGlACS/</id>
        <link href="https://zy080080.github.io/post/XECKGlACS/">
        </link>
        <updated>2020-03-19T10:46:41.000Z</updated>
        <summary type="html"><![CDATA[<p>Java基础知识总结</p>
]]></summary>
        <content type="html"><![CDATA[<p>Java基础知识总结</p>
<!-- more -->
<p><a href="#jp">日本語文章へ</a></p>
<h1 id="java基础">Java基础</h1>
<h2 id="1面向对象和面向过程的区别">1.面向对象和面向过程的区别</h2>
<ul>
<li>面向过程：面向过程性能比面向对象高。因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素时，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。</li>
<li>面向对象：面向对象易维护、易复用、易扩展。因为面向对象有封装、继承、多态的特性，所以可以设计出<strong>低耦合</strong>的系统，使系统更加灵活、更易于维护。但是面向对象性能比面向过程低。</li>
</ul>
<blockquote>
<p>面向过程性能比面向对象高？<br>
面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。<br>
而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能也并不一定比Java好。</p>
</blockquote>
<h2 id="2java语言有哪些特点">2.Java语言有哪些特点</h2>
<ol>
<li>简单易学；</li>
<li>面向对象（封装、继承、多态）；</li>
<li>平台无关性；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java语言提供了多线程支持）；</li>
<li>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<h2 id="3关于jvm-jdk和jre的最详细通俗的解答">3.关于JVM、JDK和JRE的最详细通俗的解答</h2>
<h3 id="jvm">JVM</h3>
<p>Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不用系统的特定实现（Windows，Linux，MacOS），目前是使用相同的字节码，他们都会给出相同的结果。</p>
<h4 id="什么是字节码以及采用字节码的好处">什么是字节码以及采用字节码的好处</h4>
<blockquote>
<p>在Java中，JVM可以理解的代码就叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。Java语言通过字节码的方式，在一定程度上解决了传统解释型语言（这种类型的编程语言，会将代码一句一句直接运行，不需要像编译语言一样，经过编译器先行编译为机器代码，之后再运行。）执行效率低的问题，同时又保留了解释型语言可以移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此Java程序无需重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p>Java程序从源码到运行一般有下面3步：</p>
<figure data-type="image" tabindex="1"><img src="https://camo.githubusercontent.com/8f6eceddf64b5948c69a398d1a0e777c9c7f8e5b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545382542462539302545382541312538432545382542462538372545372541382538422e706e67" alt="Java程序运行过程" loading="lazy"></figure>
<p>我们需要格外注意的是.class-&gt;机器码这一步。在这一步JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了JIT（Just In Time）编译器，而JIT属于运行时编译。当JIT编译器完成第一次编译后，会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于Java解释器的。这也解释了我们为什么经常会说Java是编译与解释共存的语言。</p>
<p>总结：<br>
Java虚拟机是运行Java字节码的虚拟机，JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，他们都会给出相同的结果。字节码和不同系统的JVM实现是Java语言“一次编译，随处运行”的关键所在。</p>
<h3 id="jdk和jre">JDK和JRE</h3>
<p>JDK（Java Development Kit）是功能最齐全的Java SDK（Software Development Kit）。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</p>
<p>JRE（Java Runtime Environment）是Java运行时环境。它是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机，Java类库，Java命令和其他的一些基础构建。但是，它不能用于创建新程序。</p>
<blockquote>
<p>Java类库：Java 官方为开发者提供了很多功能强大的类，这些类被分别放在各个包中，随JDK一起发布，称为Java类库或Java API。</p>
</blockquote>
<p>如果你只是为了运行以下Java程序的话，那么你只需要安装JRE就可以了。如果你需要运行一些Java编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web程序，那么从技术上讲，你只是在应用程序服务器中运行Java程序。那么你为什么需要JDK呢？因为应用程序服务器会将JSP转换为Java servlet，并且需要使用JDK来编译servlet。</p>
<p><a name="jp"></a></p>
<h1 id="java基礎">Java基礎</h1>
<h2 id="1オブジェクト指向言語と手続き型言語の違い">1.オブジェクト指向言語と手続き型言語の違い</h2>
<ul>
<li>手続き型言語：性能がよい。クラスを呼び出す際にインスタンス化が必要のため、オブジェクト指向言語の方が性能が下です。なので、性能が優先される時、例えばマイクロコントローラ、組み込みシステムの開発およびLinux/Unixなどで手続き言語が使われている。</li>
<li>オブジェクト指向言語：更新、再利用、拡張が便利。オブジェクト指向言語はカプセル化、継承、多態性などの特性を持ち、凝集度が高く結合度の低いシステムが設計できる。</li>
</ul>
<blockquote>
<p>C言語のようにソースコードをまとめて機械語に翻訳し実行ファイルとして保存するシステムをコンパイラと呼びます。実行ファイルはコンパイラなし単独で実行可能です。さらに機械語に翻訳済みなので、実行は高速です。<br>
Javaなどのオブジェクト指向言語では、ソースコードを中間言語コード（仮想の機械語）に翻訳するコンパイラと中間言語コードを実行するインタープリタ（仮想機械）を組み合わせた中間言語(interlanguage)方式が使われるので、性能が手続き言語より下である。</p>
<p><a href="http://www.ics.kagoshima-u.ac.jp/edu/gengo2j/p1.html" target="_blank">参考：１.Jａｖａ言語の特徴</a><br>
<a href="https://ja.wikipedia.org/wiki/Javaの性能" target="_blank">もっと詳しく：Javaの性能 ———— Wikipedia</a></p>
</blockquote>
<h2 id="2javaの特徴">2.Javaの特徴</h2>
<ol>
<li>学びやすい。</li>
<li>オブジェクト指向言語。</li>
<li>一度コードを書けばどこでも動く。</li>
<li>堅牢性。</li>
<li>セキュリティ－。</li>
<li>マルチスレッド。</li>
<li>Socket</li>
<li>JVM、JIT</li>
</ol>
<h2 id="3jvm-jdk-jre">3.JVM、JDK、JRE</h2>
<p>Java仮想マシン（Java　Virtual　Machine）は、Javaバイトコードとして定義された命令セットを実行するスタッフ型の仮想マシン。APIやいくつかのツールとセットでJava実行環境（Java　Runtime Environment）としてリリースされている。この環境を移植することで、様々な環境でJavaのプログラムを実行することができる。</p>
<p>バイトコードとは？<br>
Javaバイトコードは、Java仮想マシンが実行する命令形式である。</p>
<p>インタープリタは遅いと言われるが、Javaのバイトコードは仮想の機械語で、ソースコードを直接インタプリタで実行するよりは高速に解釈と実行が行える。さらにJVMではバイトコードを実行環境の機械語にまとめてコンパイルしてから実行するJIT（Just　In　Time　Compiler）や実行速度向上に重要な部分を選んでコンパイルし実行するHotSpotなどの手法が使われることで、実行速度は改善されている。<br>
計算機の機種やOSごとにBytecode　CompilerやJVMを用意することで、ソースコードとバイトコードは同じものが機種やOSによらず使える。Java言語は広く普及し、利用者も多いことから主要な機種とOSに対してコンパイラとJVMおよび標準クラスライブラリー（※）が用意されている。</p>
<p>※GUIの部分はOSによっても違いが出てしまう。このため、実行環境に応じたJVMだけでなく標準クラスライブラリーも用意しなければならない。バイトコードを実行するために、実行環境ごとのJRE（JVM＋標準クラスライブラリー）が提供されている。JDK（Java　Development　Kit）はJRE＋バイトコードコンパイラ等の開発環境である。<br>
<img src="http://www.ics.kagoshima-u.ac.jp/edu/gengo2j/p1/img3.gif" alt="Javaプログラムの実行" loading="lazy"><br>
<a href="http://www.ics.kagoshima-u.ac.jp/edu/gengo2j/p1.html" target="_blank">参考：１.Jａｖａ言語の特徴</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Demystifying Tomcat 4's server.xml File]]></title>
        <id>https://zy080080.github.io/post/lDrxzMPwn/</id>
        <link href="https://zy080080.github.io/post/lDrxzMPwn/">
        </link>
        <updated>2020-03-18T19:34:17.000Z</updated>
        <summary type="html"><![CDATA[<p><a name="top"></a><br>
The Tomcat server.xml file allows you to configure Tomcat using a simple XML descriptor. This XML file is at the heart of Tomcat.</p>
]]></summary>
        <content type="html"><![CDATA[<p><a name="top"></a><br>
The Tomcat server.xml file allows you to configure Tomcat using a simple XML descriptor. This XML file is at the heart of Tomcat.</p>
<!-- more -->
<p><a href="#cn">跳转至中文资料</a></p>
<p><a href="https://www.akadia.com/download/soug/tomcat/html/tomcat_server_xml.html">resource: Demystifying Tomcat 4's server.xml File - Akadia</a><br>
<br /><br>
In this article, I will focus on the configuration of all of the major Tomcat components found in the server.xml file. To examine these components, open your server.xml file, which can be found in the conf/ directory of your Tomcat installation. The following listing contains a simplified version of the default server.xml file.</p>
<p>Note: We will be focusing on the server.xml file as it is configured for Tomcat 4.0.4.</p>
<h2 id="a-simple-serverxml-file">A simple server.xml file</h2>
<pre><code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot; debug=&quot;0&quot;&gt;
  &lt;Service name=&quot;Tomcat-Standalone&quot;&gt;
    &lt;Connector className=&quot;org.apache.catalina.connector.http.HttpConnector&quot;
      port=&quot;8080&quot; minProcessors=&quot;5&quot; maxProcessors=&quot;75&quot;
      enableLookups=&quot;true&quot; redirectPort=&quot;8443&quot;
      acceptCount=&quot;10&quot; debug=&quot;0&quot; connectionTimeout=&quot;60000&quot;/&gt;
    &lt;Engine name=&quot;Standalone&quot; defaultHost=&quot;localhost&quot; debug=&quot;0&quot;&gt;
      &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot;
        prefix=&quot;catalina_log.&quot; suffix=&quot;.txt&quot;
        timestamp=&quot;true&quot;/&gt;
      &lt;Realm className=&quot;org.apache.catalina.realm.MemoryRealm&quot; /&gt;
      &lt;Host name=&quot;localhost&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot;&gt;
        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot;
          directory=&quot;logs&quot; prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot;
          pattern=&quot;common&quot;/&gt;
        &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot;
         directory=&quot;logs&quot; prefix=&quot;localhost_log.&quot; suffix=&quot;.txt&quot;
         timestamp=&quot;true&quot;/&gt;
        &lt;Context path=&quot;/examples&quot; docBase=&quot;examples&quot; debug=&quot;0&quot;
         reloadable=&quot;true&quot;&gt;
          &lt;Logger className=&quot;org.apache.catalina.logger.FileLogger&quot;
           prefix=&quot;localhost_examples_log.&quot; suffix=&quot;.txt&quot;
           timestamp=&quot;true&quot;/&gt;
         &lt;/Context&gt;
      &lt;/Host&gt;
    &lt;/Engine&gt;
  &lt;/Service&gt;
&lt;/Server&gt;
</code></pre>
<h2 id="the-server-element">The &lt;Server&gt; Element</h2>
<p>The first element found in the server.xml file is the &lt;Server&gt; element. This element represents the entire Tomcat container. It is used as a top-level element for a single Tomcat instance.</p>
<p>The &lt;Server&gt; element is defined by the org.apache.catalina.Server interface. The Server interface is a simple singleton element that represents the entire Tomcat JVM. Each &lt;Server&gt; may contain one or more Service instances. The following list defines the possible attributes that can be set for the &lt;Server&gt; element.</p>
<p><strong>className</strong>: Names the fully-qualified Java class name of the class that implements the org.apache.cataline.Server interface. If no class name is specified, the implementation will be used, which is the org.apache.catalina.core.StandardServer.</p>
<p><strong>port</strong>: Names the TCP/IP port number to which the server listens for a shutdown command. The TCP/IP client that issues the shutdown command must be running on the same computer that is running Tomcat. This attribute is required.</p>
<p><strong>shutdown</strong>: Defines the command string to shut down Tomcat. It must be received by the server on the named port. This attribute is required.</p>
<p>The &lt;Server&gt; element defined in the default server.xml file is contained in the following code snippet:</p>
<pre><code>&lt;Server port=&quot;8005&quot;
  shutdown=&quot;SHUTDOWN&quot;
  debug=&quot;0&quot;&gt;
</code></pre>
<p><strong>Note</strong>: The debug attribute is available to all Tomcat elements. It states the debug level to use when logging messages to a defined Logger. We will look at a Logger definition later in this article.</p>
<p>The &lt;Server&gt; element cannot be configured as a child of any elements. It can be configured as a parent to the &lt;Service&gt; element.</p>
<h2 id="the-service-element">The &lt;Service&gt; Element</h2>
<p>The next element in the server.xml file is the &lt;Service&gt; element, which acts as a container for one or more &lt;Connector&gt; elements that share a single &lt;Engine&gt; element. One or more &lt;Service&gt; elements may be nested inside of a single &lt;Server&gt; element. The &lt;Service&gt; element is defined by the org.apache.catalina.Service interface. The following list describes the possible &lt;Service&gt; element attributes.</p>
<p><strong>className</strong>: Names the fully-qualified Java class name of the class that implements the org.apache.cataline.Service interface. If no class name is specified, the implementation will be used, which is the org.apache.catalina.core.StandardService.</p>
<p><strong>shutdown</strong>: Defines the command string to shut down Tomcat. It must be received by the server on the named port. This attribute is required.</p>
<p>The &lt;Service&gt; element found in our server.xml file describes a service that represents a stand-alone Tomcat service that will handle all direct requests received by Tomcat.</p>
<pre><code>&lt;Service name=&quot;Tomcat-Standalone&quot;&gt;
</code></pre>
<p><strong>Note</strong>: I will discuss how to add additional <Service> elements in a subsequent article.</p>
<p>The &lt;Service&gt; element can be configured as a child of the &lt;Server&gt; element. It can be configured as a parent to the &lt;Connector&gt; and &lt;Engine&gt; elements.</p>
<h2 id="the-engine-element">The &lt;Engine&gt; Element</h2>
<p>The third element in the server.xml file is the &lt;Engine&gt; element, which represents the Catalina servlet container. There can only be one &lt;Engine&gt; element for each defined &lt;Service&gt;. This single &lt;Engine&gt; component will receive all requests received by all of the defined &lt;Connector&gt; components. The &lt;Engine&gt; element must be nested immediately after the &lt;Connector&gt; elements, inside of its owning &lt;Service&gt; element.</p>
<p>The &lt;Engine&gt; element is defined by the org.apache.catalina.Engine interface. The following list describes the possible &lt;Engine&gt; element attributes.</p>
<p><strong>className</strong>: Names the fully-qualified Java class name of the class that implements the org.apache.cataline.Engine interface. If no class name is specified, the implementation will be used, which is the org.apache.catalina.core.StandardEngine.</p>
<p><strong>defaultHost</strong>: Names the host name to which all requests will be defaulted if not otherwise named. The named host must be defined by a child &lt;Host&gt; element.</p>
<p><strong>name</strong>: Defines the logical name of this engine. The name selected is arbitrary, but it is required.</p>
<p>The following code snippet contains the &lt;Engine&gt; element defined in the server.xml file. The element defines an engine named Standalone with a default host of localhost.</p>
<pre><code>&lt;Engine name=&quot;Standalone&quot; defaultHost=&quot;localhost&quot; debug=&quot;0&quot;&gt;
</code></pre>
<p>The <Engine> element can be configured as a child of the <Service> element. It can be configured as a parent to the following elements:</p>
<ul>
<li>&lt;Logger&gt;</li>
<li>&lt;Realm&gt;</li>
<li>&lt;Valve&gt;</li>
<li>&lt;Host&gt;</li>
</ul>
<h2 id="the-host-element">The &lt;Host&gt; Element</h2>
<p>The &lt;Host&gt; element defines the virtual hosts that are contained in each instance of a Catalina &lt;Engine&gt;. Each &lt;Host&gt; can be a parent to one or more Web applications, which are represented by a &lt;Context&gt; component, which will be described in the following section.</p>
<p>You must define at least one &lt;Host&gt; for each Engine element. The possible attributes for the <Host> element are described below.</p>
<p><strong>className</strong>: Names the fully-qualified Java class name of the class that implements the org.apache.catalina.Host interface. If no class name is specified, the implementation will be used, which is the org.apache.catalina.core.StandardHost.</p>
<p><strong>appBase</strong>: Defines the directory for this virtual host. This directory is the pathname of the Web applications to be executed in this virtual host. This value can be an absolute path, or a path that is relative to the &lt;CATALINA_HOME&gt; directory. If this value is not specified, the relative value webapps will be used.</p>
<p><strong>unpackWARs</strong>: Determines if WAR files should be unpacked, or run directly from the WAR file. If not specified, the default value is true.</p>
<blockquote>
<p>WAR. Is the extension of a file that packages a web application directory hierarchy in ZIP format and is short for Web Archive. Java web applications are usually packaged as WAR files for deployment. These files can be created on the command line or with an IDE like Eclipse.</p>
<p>After deploying our WAR file, Tomcat unpacks it and stores all project files in the webapps directory in a new directory named after the project.</p>
<p><a href="https://www.baeldung.com/tomcat-deploy-war">resource:How to Deploy a WAR File to Tomcat</a></p>
</blockquote>
<p><strong>name</strong>: Defines host name of this virtual host. This attribute is required, and must be unique among the virtual hosts running in this servlet container.</p>
<p>The &lt;Host&gt; element defined for the Standalone &lt;Engine&gt; is listed in the following code snippet:</p>
<pre><code>&lt;Host name=&quot;localhost&quot; debug=&quot;0&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot;&gt;
</code></pre>
<p>The host definition defines a host named localhost that can be accessed by opening the URL http://localhost:8080/.</p>
<p><strong>Note</strong>: The port 8080 appended to the previous URL is defined by the <Connector> element, which will be described later in this article.</p>
<p>The &lt;Host&gt; element is configured as a child of the &lt;Engine&gt; element. It can be configured as a parent to the following elements:</p>
<ul>
<li>&lt;Logger&gt;</li>
<li>&lt;Realm&gt;</li>
<li>&lt;Valve&gt;</li>
<li>&lt;Context&gt;</li>
</ul>
<h2 id="the-context-element">The &lt;Context&gt; Element</h2>
<p>The &lt;Context&gt; element is the most commonly used element in the server.xml file. It represents an individual Web application that is running within a defined &lt;Host&gt;. There is no limit to the number of contexts that can be defined within a &lt;Host&gt; element. Each &lt;Context&gt; definition must have a unique context path, which is defined by the path attribute. The possible attributes for the &lt;Context&gt; element are described below.</p>
<p><strong>className</strong>: Names the fully-qualified Java class name of the class that implements the org.apache.catalina.Host interface. If no class name is specified, the implementation will be used, which is the org.apache.catalina.core.StandardContext.</p>
<p><strong>cookies</strong>: Determines if you want cookies to be used for session identifier. The default value is true.</p>
<p><strong>crossContext</strong>: When set to true, allows the ServletContext.getContext() method to successfully return the ServletContext for other Web applications running in the same host. The default value is false, which will prevent the access of cross-context access.</p>
<p><strong>docBase</strong>: Defines the directory for the Web application associated with this &lt;Context&gt;. This is the pathname of a directory that contains the resources for the Web application.</p>
<p><strong>path</strong>: Defines the context path for this Web application. This value must be unique for each &lt;Context&gt; defined in a given &lt;Host&gt;.</p>
<p><strong>reloadable</strong>: If set to true, causes Tomcat to check for class changes in the WEB-INF/classes/ and WEB-INF/lib directories. If these classes have changed, the application owning these classes will automatically be reloaded. This feature should only be used during development. This setting will cause severe performance degradation, and therefore should be set to false when in a production environment.</p>
<p><strong>wrapperClass</strong>: Defines the Java class name of the org.apache.catalina.Wrapper implementation class that will be used to wrap servlets managed by this Context. If not specified, the standard value org.apache.catalina.core.StandardWrapper will be used.</p>
<p><strong>useNaming</strong>: Set this value to true if you want Catalina to enable JNDI. The default value is true.</p>
<blockquote>
<p>JNDI(Java Naming and Directory Interface,Java命名和目录接口)</p>
</blockquote>
<p><strong>override</strong>: Set this value to override the DefaultContext configuration.The default value is false.</p>
<p><strong>workDir</strong>: Defines the pathname to a scratch directory that will be used by this &lt;Context&gt; for temporary read and write access. The directory will be made visible as a servlet context attribute of type java.io.File, with the standard key of java.servlet.context.tempdir. If this value is not specified, Tomcat will use the work directory.</p>
<p>The &lt;Context&gt; element that defines the /examples application is included in the following code snippet:</p>
<pre><code>&lt;Context path=&quot;/examples&quot; docBase=&quot;examples&quot; debug=&quot;0&quot;
reloadable=&quot;true&quot;&gt;
</code></pre>
<p>The context definition defines a Web application named /examples that will have all of its resources stored in the directory &lt;TOMCAT_HOME&gt;/Webapps/examples (examples contains WEB-INF). This context also states that this application will be reloaded when class files are changed.</p>
<p>The &lt;Context&gt; element is configured as a child of the &lt;Host&gt; element. It can be configured as a parent to the following elements:</p>
<ul>
<li>&lt;Logger&gt;</li>
<li>&lt;Loader&gt;</li>
<li>&lt;Realm&gt;</li>
<li>&lt;Manager&gt;</li>
<li>&lt;Ejb&gt;</li>
<li>&lt;Environment&gt;</li>
<li>&lt;Parameter&gt;</li>
<li>&lt;Resource&gt;</li>
<li>&lt;ResourceParams&gt;</li>
</ul>
<p><strong>Note</strong>: If you do not have special configuration needs, you can use the default context configuration that is described in the default web.xml file, which can be found in the &lt;CATALINA_HOME&gt;/conf/ directory.</p>
<h2 id="the-connector-element">The &lt;Connector&gt; Element</h2>
<p>The final element we are going to examine is the &lt;Connector&gt; element. The &lt;Connector&gt; element defines the component that does the actual managing of requests and responses to and from a calling client. The &lt;Connector&gt; element is defined by the org.apache.catalina.Connector interface. The &lt;Connector&gt; element's attributes are described below.</p>
<p><strong>className</strong>: Names the fully-qualified Java class name of the class that implements the org.apache.catalina.Host interface. If no class name is specified, the implementation will be used, which is the org.apache.catalina.Connector interface.</p>
<p><strong>enableLookups</strong>: Determines whether DNS lookups are enabled. The default value for this attribute is true. When DNS lookups are enabled, an application calling request.getRemoteHost() will be returned the domain name of the calling client. Enabling DNS lookups can have an unfavorable impact on performance, so this value should most often be set to false.</p>
<p><strong>redirectPort</strong>: Names the TCP/IP port number to which a request should be redirected, if it comes in on a non-SSL port, and is subject to a security constraint with a transport guarantee that requires SSL.</p>
<p><strong>name</strong>: Defines host name of this virtual host. This attribute is required, and must be unique among the virtual hosts running in this servlet container.</p>
<p>The &lt;Connector&gt; element is configured as a child of the &lt;Service&gt; element. It cannot be configured as a parent to any element.</p>
<h2 id="the-http-connector">The HTTP Connector</h2>
<p>The most common Tomcat connector is the HTTP connector, which is preconfigured with Tomcat. Like all connectors, the HTTP connector implements the org.apache.catalina.Connector interface, which automatically associates it with the connector attributes described above, but it also defines a set of attributes that are specific to the HttpConnector. These additional attributes are listed here.</p>
<p><strong>port</strong>: Names the TCP/IP port number on which the connector listens for requests. The default value is 8080. If you want Tomcat to process requests using the default HTTP port of 80, simply set this attribute to 80.</p>
<p><strong>address</strong>: This attribute is used for servers with more than one IP address. It specifies which address will be used for listening on the specified port. If this attribute is not specified, this named port number will be used on all IP addresses associated with this server.</p>
<p><strong>bufferSize</strong>: Specifies the size, in bytes, of the buffer to be provided for use by input streams created by this connector. Increasing the buffer size can improve performance, at the expense of higher memory usage. The default value is 2048 bytes.</p>
<p><strong>className</strong>: Names the fully-qualified Java class name of the HTTP connector class. This value must equal org.apache.cataline.connector.http.HttpConnector.</p>
<p><strong>enableLookups</strong>: Same for all connectors.</p>
<p><strong>proxyName</strong>: Specifies the server name to use if this instance of Tomcat is behind a firewall. This is an optional attribute.</p>
<p><strong>proxyPort</strong>: Specifies the HTTP port to use if this instance of Tomcat is behind a firewall. An optional attribute.</p>
<p><strong>minProcessors</strong>: Defines the minimum number of processors, or instances, to start at initialization time. The default value is 5.</p>
<p><strong>maxProcessors</strong>: Defines the maximum number of allowed processors, or instances, that can be started. The default value is 20. An unlimited number of processors can be started if the value of the maxProcessors attribute is set to a number less than zero.</p>
<p><strong>acceptCount</strong>: Specifies the number of requests that can be queued on the listening port. The default value is 10.</p>
<p><strong>connectionTimeout</strong>: Defines time, in milliseconds, before a request terminates. The default value is 60000 milliseconds. To disable connection timeouts, the connectionTimeout value should be set to -1.</p>
<p>An example &lt;Connector&gt; defining a HTTP connector is contained in the following code snippet:</p>
<pre><code>&lt;Connector className=&quot;org.apache.catalina.connector.http.HttpConnector&quot;
  port=&quot;8080&quot;
  minProcessors=&quot;5&quot;
  maxProcessors=&quot;75&quot;
  enableLookups=&quot;true&quot;
  redirectPort=&quot;8443&quot;
  acceptCount=&quot;10&quot;
  debug=&quot;0&quot;
  connectionTimeout=&quot;60000&quot;/&gt;
</code></pre>
<p>This &lt;Connector&gt; defines an HttpConnector that listens for requests on port 8080. It starts with a minimum of five processors and can start up to as many as 75 processors.</p>
<p><a href="#top">TOP</a></p>
<hr>
<p><a name="cn"></a></p>
<h1 id="中文资料">中文资料</h1>
<p><a href="https://www.cnblogs.com/kismetv/p/7228274.html">来源：详解Tomcat 配置文件server.xml</a></p>
<h2 id="serverxml配置实例">server.xml配置实例</h2>
<pre><code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;  
    &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;  
    &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;  
    &lt;Listener className=&quot;org.apache.catalina.core.JasperListener&quot; /&gt;  
    &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;  
    &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;  
    &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;  

    &lt;GlobalNamingResources&gt;  
     &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;  
               type=&quot;org.apache.catalina.UserDatabase&quot;  
               description=&quot;User database that can be updated and saved&quot;  
               factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;  
               pathname=&quot;conf/tomcat-users.xml&quot; /&gt;  
   &lt;/GlobalNamingResources&gt;  

&lt;Service name=&quot;Catalina&quot;&gt;  
 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;  
                connectionTimeout=&quot;20000&quot;  
                redirectPort=&quot;8443&quot; /&gt;  
     &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;  
  &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;  
    &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;  
      &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;  
             resourceName=&quot;UserDatabase&quot;/&gt;  
    &lt;/Realm&gt;  

    &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;  
          unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;  
      &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;  
             prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot;  
             pattern=&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; /&gt;  
    &lt;/Host&gt;  
  &lt;/Engine&gt;  
&lt;/Service&gt;   &lt;/Server&gt;
</code></pre>
<h2 id="1-整体结构">1、整体结构</h2>
<p>server.xml的整体结构如下：</p>
<pre><code>&lt;Server&gt;  
     &lt;Service&gt;  
        &lt;Connector /&gt;  
        &lt;Connector /&gt;  
         &lt;Engine&gt;  
             &lt;Host&gt;  
                &lt;Context /&gt;&lt;!-- 现在常常使用自动部署，不推荐配置Context元素，Context小节有详细说明 --&gt;  
           &lt;/Host&gt;  
        &lt;/Engine&gt;  
   &lt;/Service&gt;  &lt;/Server&gt;
</code></pre>
<h2 id="2-元素分类">2、元素分类</h2>
<p>server.xml文件中的元素可以分为以下4类：</p>
<p>（1）顶层元素：<Server>和<Service></p>
<p><Server>元素是整个配置文件的根元素，<Service>元素则代表一个Engine元素以及一组与之相连的Connector元素。</p>
<p>（2）连接器：<Connector></p>
<p><Connector>代表了外部客户端发送请求到特定Service的接口；同时也是外部客户端从特定Service接收响应的接口。</p>
<p>（3）容器：<Engine><Host><Context></p>
<p>容器的功能是处理Connector接收进来的请求，并产生相应的响应。Engine、Host和Context都是容器，但它们不是平行的关系，而是父子关系：Engine包含Host，Host包含Context。一个Engine组件可以处理Service中的所有请求，一个Host组件可以处理发向一个特定虚拟主机的所有请求，一个Context组件可以处理一个特定Web应用的所有请求。</p>
<p>（4）内嵌组件：可以内嵌到容器中的组件。实际上，Server、Service、Connector、Engine、Host和Context是最重要的最核心的Tomcat组件，其他组件都可以归为内嵌组件。</p>
<p>下面将详细介绍Tomcat中各个核心组件的作用，以及相互之间的关系。</p>
<h2 id="3-核心组件">3、核心组件</h2>
<h3 id="1-server">1、Server</h3>
<p>Server元素在最顶层，代表整个Tomcat容器，因此它必须是server.xml中唯一一个最外层的元素。<strong>一个Server元素中可以有一个或多个Service元素。</strong></p>
<p>在第一部分的例子中，在最外层有一个<Server>元素，shutdown属性表示关闭Server的指令；port属性表示Server接收shutdown指令的端口号，设为-1可以禁掉该端口。</p>
<p>Server的主要任务，就是提供一个接口让客户端能够访问到这个Service集合，同时维护它所包含的所有的Service的声明周期，包括如何初始化、如何结束服务、如何找到客户端要访问的Service。</p>
<h3 id="2-service">2、Service</h3>
<p>Service的作用，是在Connector和Engine外面包了一层，把它们组装在一起，对外提供服务。一个Service可以包含多个Connector，但是只能包含一个Engine；其中Connector的作用是从客户端接收请求，Engine的作用是处理接收进来的请求。</p>
<p>在第一部分的例子中，Server中包含一个名称为“Catalina”的Service。实际上，Tomcat可以提供多个Service，不同的Service监听不同的端口，后文会有介绍。</p>
<h3 id="3-connector">3、Connector</h3>
<p>Connector的主要功能，是接收连接请求，创建Request和Response对象用于和请求端交换数据；然后分配线程让Engine来处理这个请求，并把产生的Request和Response对象传给Engine。</p>
<p>通过配置Connector，可以控制请求Service的协议及端口号。在第一部分的例子中，Service包含两个Connector：</p>
<pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;
&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<p>（1）通过配置第1个Connector，客户端可以通过8080端口号使用http协议访问Tomcat。其中，protocol属性规定了请求的协议，port规定了请求的端口号，redirectPort表示当强制要求https而请求是http时，重定向至端口号为8443的Connector，connectionTimeout表示连接的超时时间。</p>
<p>在这个例子中，Tomcat监听HTTP请求，使用的是8080端口，而不是正式的80端口；实际上，在正式的生产环境中，Tomcat也常常监听8080端口，而不是80端口。这是因为在生产环境中，很少将Tomcat直接对外开放接收请求，而是在Tomcat和客户端之间加一层代理服务器(如nginx)，用于请求的转发、负载均衡、处理静态文件等；通过代理服务器访问Tomcat时，是在局域网中，因此一般仍使用8080端口。</p>
<p>（2）通过配置第2个Connector，客户端可以通过8009端口号使用AJP协议访问Tomcat。AJP协议负责和其他的HTTP服务器(如Apache)建立连接；在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。之所以使用Tomcat和其他服务器集成，是因为Tomcat可以用作Servlet/JSP容器，但是对静态资源的处理速度较慢，不如Apache和IIS等HTTP服务器；因此常常将Tomcat与Apache等集成，前者作Servlet容器，后者处理静态资源，而AJP协议便负责Tomcat和Apache的连接。Tomcat与Apache等集成的原理如下图:</p>
<figure data-type="image" tabindex="1"><img src="https://pic3.zhimg.com/80/v2-6089ce4b26d0ab9bf372057a327afa76_1440w.jpg" alt="Tomcat与Apache等集成的原理" loading="lazy"></figure>
<h3 id="4-engine">4、Engine</h3>
<p>**Engine组件在Service组件中有且只有一个；Engine是Service组件中的请求处理组件。**Engine组件从一个或多个Connector中接收请求并处理，并将完成的响应返回给Connector，最终传递给客户端。</p>
<p>前面已经提到过，Engine、Host和Context都是容器，但它们不是平行的关系，而是父子关系：Engine包含Host，Host包含Context。</p>
<p>在第一部分的例子中，Engine的配置语句如下：</p>
<pre><code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;
</code></pre>
<p>其中，name属性用于日志和错误信息，在整个Server中应该唯一。defaultHost属性指定了默认的host名称，当发往本机的请求指定的host名称不存在时，一律使用defaultHost指定的host进行处理；因此，defaultHost的值，必须与Engine中的一个Host组件的name属性值匹配。</p>
<h3 id="5-host">5、Host</h3>
<h4 id="1engine与host">（1）Engine与Host</h4>
<p>Host是Engine的子容器。Engine组件中可以内嵌1个或多个Host组件，每个Host组件代表Engine中的一个虚拟主机。<strong>Host组件至少有一个，且其中一个的name必须与Engine组件的defaultHost属性相匹配。</strong></p>
<h4 id="2host的作用">（2）Host的作用</h4>
<p>Host虚拟主机的作用，是运行多个Web应用（一个Context代表一个Web应用），并负责安装、展开、启动和结束每个Web应用。</p>
<p>Host组件代表的虚拟主机，对应了服务器中一个网络名实体(如”www.test.com”，或IP地址”116.25.25.25”)；为了使用户可以通过网络名连接Tomcat服务器，这个名字应该在DNS服务器上注册。</p>
<p>客户端通常使用主机名来标识它们希望连接的服务器；该主机名也会包含在HTTP请求头中。Tomcat从HTTP头中提取出主机名，寻找名称匹配的主机。如果没有匹配，请求将发送至默认主机。因此默认主机不需要是在DNS服务器中注册的网络名，因为任何与所有Host名称不匹配的请求，都会路由至默认主机。</p>
<h4 id="3host的配置">（3）Host的配置</h4>
<p>在第一部分的例子中，Host的配置如下：</p>
<pre><code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
</code></pre>
<p>下面对其中配置的属性进行说明：</p>
<p>name属性指定虚拟主机的主机名，一个Engine中有且仅有一个Host组件的name属性与Engine组件的defaultHost属性相匹配；一般情况下，主机名需要是在DNS服务器中注册的网络名，但是Engine指定的defaultHost不需要，原因在前面已经说明。</p>
<p>unpackWARs指定了是否将代表Web应用的WAR文件解压；如果为true，通过解压后的文件结构运行该Web应用，如果为false，直接使用WAR文件运行Web应用。</p>
<p>Host的autoDeploy和appBase属性，与Host内Web应用的自动部署有关；此外，本例中没有出现的xmlBase和deployOnStartup属性，也与Web应用的自动部署有关；将在下一节(Context)中介绍。</p>
<h3 id="6-context">6、Context</h3>
<h4 id="1context的作用">（1）Context的作用</h4>
<p>Context元素代表在特定虚拟主机上运行的一个Web应用。在后文中，提到Context、应用或Web应用，它们指代的都是Web应用。每个Web应用基于WAR文件，或WAR文件解压后对应的目录（这里称为应用目录）。</p>
<p>Context是Host的子容器，每个Host中可以定义任意多的Context元素。</p>
<p>在第一部分的例子中，可以看到server.xml配置文件中并没有出现Context元素的配置。这是因为，Tomcat开启了自动部署，Web应用没有在server.xml中配置静态部署，而是由Tomcat通过特定的规则自动部署。下面介绍一下Tomcat自动部署Web应用的机制。</p>
<h4 id="2web应用自动部署">（2）Web应用自动部署</h4>
<h5 id="host的配置">Host的配置</h5>
<p>要开启Web应用的自动部署，需要配置所在的虚拟主机；配置的方式就是前面提到的Host元素的deployOnStartup和autoDeploy属性。如果deployOnStartup和autoDeploy设置为true，则tomcat启动自动部署：当检测到新的Web应用或Web应用的更新时，会触发应用的部署(或重新部署)。二者的主要区别在于，deployOnStartup为true时，Tomcat在启动时检查Web应用，且检测到的所有Web应用视作新应用；autoDeploy为true时，Tomcat在运行时定期检查新的Web应用或Web应用的更新。除此之外，二者的处理相似。</p>
<p>通过配置deployOnStartup和autoDeploy可以开启虚拟主机自动部署Web应用；实际上，自动部署依赖于检查是否有新的或更改过的Web应用，而Host元素的appBase和xmlBase设置了检查Web应用更新的目录。</p>
<p>其中，appBase属性指定Web应用所在的目录，默认值是webapps，这是一个相对路径，代表Tomcat根目录下webapps文件夹。</p>
<p>xmlBase属性指定Web应用的XML配置文件所在的目录，默认值为conf/&lt;engine_name&gt;/&lt;host_name&gt;，例如第一部分的例子中，主机localhost的xmlBase的默认值是$TOMCAT_HOME/conf/Catalina/localhost。</p>
<h5 id="检查web应用更新">检查Web应用更新</h5>
<p>一个Web应用可能包括以下文件：XML配置文件，WAR包，以及一个应用目录(该目录包含Web应用的文件结构)；其中XML配置文件位于xmlBase指定的目录，WAR包和应用目录位于appBase指定的目录。</p>
<p>Tomcat按照如下的顺序进行扫描，来检查应用更新：</p>
<p>A、扫描虚拟主机指定的xmlBase下的XML配置文件</p>
<p>B、扫描虚拟主机指定的appBase下的WAR文件</p>
<p>C、扫描虚拟主机指定的appBase下的应用目录</p>
<h5 id="context元素的配置"><Context>元素的配置</h5>
<p>Context元素最重要的属性是docBase和path，此外reloadable属性也比较常用。</p>
<p>docBase指定了该Web应用使用的WAR包路径，或应用目录。<strong>需要注意的是，在自动部署场景下(配置文件位于xmlBase中)，docBase不在appBase目录中，才需要指定</strong>；如果docBase指定的WAR包或应用目录就在docBase中，则不需要指定，因为Tomcat会自动扫描appBase中的WAR包和应用目录，指定了反而会造成问题。</p>
<p>path指定了访问该Web应用的上下文路径，当请求到来时，Tomcat根据Web应用的 path属性与URI的匹配程度来选择Web应用处理相应请求。例如，Web应用app1的path属性是”/app1”，Web应用app2的path属性是”/app2”，那么请求/app1/index.html会交由app1来处理；而请求/app2/index.html会交由app2来处理。如果一个Context元素的path属性为””，那么这个Context是虚拟主机的默认Web应用；当请求的uri与所有的path都不匹配时，使用该默认Web应用来处理。</p>
<p>但是，需要注意的是，在自动部署场景下(配置文件位于xmlBase中)，不能指定path属性，path属性由配置文件的文件名、WAR文件的文件名或应用目录的名称自动推导出来。如扫描Web应用时，发现了xmlBase目录下的app1.xml，或appBase目录下的app1.WAR或app1应用目录，则该Web应用的path属性是”app1”。如果名称不是app1而是ROOT，则该Web应用是虚拟主机默认的Web应用，此时path属性推导为””。</p>
<p>reloadable属性指示tomcat是否在运行时监控在WEB-INF/classes和WEB-INF/lib目录下class文件的改动。如果值为true，那么当class文件改动时，会触发Web应用的重新加载。在开发环境下，reloadable设置为true便于调试；但是在生产环境中设置为true会给服务器带来性能压力，因此reloadable参数的默认值为false。</p>
<p>下面来看自动部署时，xmlBase下的XML配置文件app1.xml的例子：</p>
<pre><code>&lt;Context docBase=&quot;D:\Program Files\app1.war&quot; reloadable=&quot;true&quot;/&gt;
</code></pre>
<p>在该例子中，docBase位于Host的appBase目录之外；path属性没有指定，而是根据app1.xml自动推导为”app1”；由于是在开发环境下，因此reloadable设置为true，便于开发调试。</p>
<h5 id="自动部署举例">自动部署举例</h5>
<p>最典型的自动部署，就是当我们安装完Tomcat后，$TOMCAT_HOME/webapps目录下有如下文件夹：</p>
<figure data-type="image" tabindex="2"><img src="https://pic2.zhimg.com/80/v2-ed36647466c882d4b1e19b4656961af1_1440w.jpg" alt="文件夹" loading="lazy"></figure>
<p>当我们启动Tomcat后，可以使用http://localhost:8080/来访问Tomcat，其实访问的就是ROOT对应的Web应用；我们也可以通过http://localhost:8080/docs来访问docs应用，同理我们可以访问examples/host-manager/manager这几个Web应用。</p>
<h4 id="3serverxml中静态部署web应用">（3）server.xml中静态部署Web应用</h4>
<p>除了自动部署，我们也可以在server.xml中通过<context>元素静态部署Web应用。静态部署与自动部署是可以共存的。在实际应用中，并不推荐使用静态部署，因为server.xml 是不可动态重加载的资源，服务器一旦启动了以后，要修改这个文件，就得重启服务器才能重新加载。而自动部署可以在Tomcat运行时通过定期的扫描来实现，不需要重启服务器。</p>
<p>server.xml中使用Context元素配置Web应用，Context元素应该位于Host元素中。举例如下：</p>
<pre><code>&lt;Context path=&quot;/&quot; docBase=&quot;D:\Program Files \app1.war&quot; reloadable=&quot;true&quot;/&gt;
</code></pre>
<p>docBase：静态部署时，docBase可以在appBase目录下，也可以不在；本例中，docBase不在appBase目录下。</p>
<p>path：静态部署时，可以显式指定path属性，但是仍然受到了严格的限制：只有当自动部署完全关闭(deployOnStartup和autoDeploy都为false)或docBase不在appBase中时，才可以设置path属性。在本例中，docBase不在appBase中，因此path属性可以设置。</p>
<p>reloadable属性的用法与自动部署时相同。</p>
<p><a href="#top">返回顶部</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML标签英文全称]]></title>
        <id>https://zy080080.github.io/post/cHLSqLDIx/</id>
        <link href="https://zy080080.github.io/post/cHLSqLDIx/">
        </link>
        <updated>2020-03-06T00:26:17.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<html>
<body>
  <table>
    <thead>
      <tr>
        <th>标签</th>
        <th>全称</th>
        <th>描述</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>&lt; !–…– &gt;</td>
        <td></td>
        <td>定义注释。</td>
      </tr>
      <tr>
        <td>&lt; !DOCTYPE &gt;</td>
        <td></td>
        <td>定义文档类型。</td>
      </tr>
      <tr>
        <td>&lt; a &gt;</td>
        <td>anchor</td>
        <td>定义锚。</td>
      </tr>
      <tr>
        <td>&lt; abbr&gt;</td>
        <td>abbreviation</td>
        <td>定义缩写。</td>
      </tr>
      <tr>
        <td>&lt; acronym&gt;</td>
        <td>acronym</td>
        <td>定义只取首字母的缩写。</td>
      </tr>
      <tr>
        <td>&lt; address&gt;</td>
        <td>address</td>
        <td>定义文档作者或拥有者的联系信息。</td>
      </tr>
      <tr>
        <td>&lt; applet&gt;</td>
        <td>applet</td>
        <td>不赞成使用。定义嵌入的 applet。</td>
      </tr>
      <tr>
        <td>&lt; area&gt;</td>
        <td>area</td>
        <td>定义图像映射内部的区域。</td>
      </tr>
      <tr>
        <td>&lt; b&gt;</td>
        <td>blod</td>
        <td>定义粗体字。</td>
      </tr>
      <tr>
        <td>&lt; base&gt;</td>
        <td>base</td>
        <td>定义页面中所有链接的默认地址或默认目标。</td>
      </tr>
      <tr>
        <td>&lt; basefont&gt;</td>
        <td>Basefont</td>
        <td>不赞成使用。定义页面中文本的默认字体、颜色或尺寸。</td>
      </tr>
      <tr>
        <td>&lt; bdo&gt;</td>
        <td>bidirectional override</td>
        <td>定义文字方向。</td>
      </tr>
      <tr>
        <td>&lt; big&gt;</td>
        <td>big</td>
        <td>定义大号文本。</td>
      </tr>
      <tr>
        <td>&lt; blockquote&gt;</td>
        <td>blockquote</td>
        <td>定义长的引用。</td>
      </tr>
      <tr>
        <td>&lt; body&gt;</td>
        <td>Body</td>
        <td>定义文档的主体。</td>
      </tr>
      <tr>
        <td>&lt; br&gt;</td>
        <td>Break</td>
        <td>定义简单的折行。</td>
      </tr>
      <tr>
        <td>&lt; button&gt;</td>
        <td>Button</td>
        <td>定义按钮 (push button)。</td>
      </tr>
      <tr>
        <td>&lt; caption&gt;</td>
        <td>Caption</td>
        <td>定义表格标题。</td>
      </tr>
      <tr>
        <td>&lt; center&gt;</td>
        <td>Center</td>
        <td>不赞成使用。定义居中文本。</td>
      </tr>
      <tr>
        <td>&lt; cite&gt;</td>
        <td>Cite</td>
        <td>定义引用(citation)。</td>
      </tr>
      <tr>
        <td>&lt; code&gt;</td>
        <td>Code</td>
        <td>定义计算机代码文本。</td>
      </tr>
      <tr>
        <td>&lt; col&gt;</td>
        <td>Column</td>
        <td>定义表格中一个或多个列的属性值。</td>
      </tr>
      <tr>
        <td>&lt; colgroup&gt;</td>
        <td>Colgroup</td>
        <td>定义表格中供格式化的列组。</td>
      </tr>
      <tr>
        <td>&lt; dd&gt;</td>
        <td>definition description</td>
        <td>定义定义列表中项目的描述。</td>
      </tr>
      <tr>
        <td>&lt; del&gt;</td>
        <td>delete</td>
        <td>定义被删除文本。</td>
      </tr>
      <tr>
        <td>&lt; dir&gt;</td>
        <td></td>
        <td>不赞成使用。定义目录列表。</td>
      </tr>
      <tr>
        <td>&lt; div&gt;</td>
        <td>division</td>
        <td>定义文档中的节（块）。</td>
      </tr>
      <tr>
        <td>&lt; dfn&gt;</td>
        <td>defining instance</td>
        <td>定义定义项目。</td>
      </tr>
      <tr>
        <td>&lt; dl&gt;</td>
        <td>definition list</td>
        <td>定义定义列表。</td>
      </tr>
      <tr>
        <td>&lt; dt&gt;</td>
        <td>definition term</td>
        <td>定义定义列表中的项目。</td>
      </tr>
      <tr>
        <td>&lt; em&gt;</td>
        <td>emphasized</td>
        <td>定义强调文本。</td>
      </tr>
      <tr>
        <td>&lt; fieldset&gt;</td>
        <td>Fieldset</td>
        <td>定义围绕表单中元素的边框。域集</td>
      </tr>
      <tr>
        <td>&lt; font&gt;</td>
        <td>Font</td>
        <td>不赞成使用。定义文字的字体、尺寸和颜色。</td>
      </tr>
      <tr>
        <td>&lt; form&gt;</td>
        <td>Form</td>
        <td>定义供用户输入的 HTML 表单。</td>
      </tr>
      <tr>
        <td>&lt; frame&gt;</td>
        <td>Frame</td>
        <td>定义框架集的窗口或框架。</td>
      </tr>
      <tr>
        <td>&lt; frameset&gt;</td>
        <td>Frameset</td>
        <td>定义框架集。</td>
      </tr>
      <tr>
        <td>&lt; h1&gt; to &lt; h6&gt;</td>
        <td>Header1 to Header6</td>
        <td>定义 HTML 标题。</td>
      </tr>
      <tr>
        <td>&lt; head&gt;</td>
        <td>Head</td>
        <td>定义关于文档的信息。</td>
      </tr>
      <tr>
        <td>&lt; hr&gt;</td>
        <td>horizontal</td>
        <td>定义水平线。</td>
      </tr>
      <tr>
        <td>&lt; html&gt;</td>
        <td>hypertext markup language</td>
        <td>定义 HTML 文档。</td>
      </tr>
      <tr>
        <td>&lt; i&gt;</td>
        <td>italic</td>
        <td>定义斜体字。</td>
      </tr>
      <tr>
        <td>&lt; iframe&gt;</td>
        <td>inline frame</td>
        <td>定义内联框架。</td>
      </tr>
      <tr>
        <td>&lt; img&gt;</td>
        <td>Image</td>
        <td>定义图像。</td>
      </tr>
      <tr>
        <td>&lt; input&gt;</td>
        <td>Input</td>
        <td>定义输入控件。</td>
      </tr>
      <tr>
        <td>&lt; ins&gt;</td>
        <td>inserted</td>
        <td>定义被插入文本。</td>
      </tr>
      <tr>
        <td>&lt; isindex&gt;</td>
        <td></td>
        <td>不赞成使用。定义与文档相关的可搜索索引。</td>
      </tr>
      <tr>
        <td>&lt; kbd&gt;</td>
        <td>keyboard</td>
        <td>定义键盘文本。</td>
      </tr>
      <tr>
        <td>&lt; label&gt;</td>
        <td>Label</td>
        <td>定义 input 元素的标注。</td>
      </tr>
      <tr>
        <td>&lt; legend&gt;</td>
        <td>legend</td>
        <td>定义域集元素的标题。</td>
      </tr>
      <tr>
        <td>&lt; li&gt;</td>
        <td>List</td>
        <td>定义列表的项目。</td>
      </tr>
      <tr>
        <td>&lt; link&gt;</td>
        <td>Link</td>
        <td>定义文档与外部资源的关系。</td>
      </tr>
      <tr>
        <td>&lt; map&gt;</td>
        <td>Map</td>
        <td>定义图像映射。</td>
      </tr>
      <tr>
        <td>&lt; menu&gt;</td>
        <td>Menu</td>
        <td>不赞成使用。定义菜单列表。</td>
      </tr>
      <tr>
        <td>&lt; meta&gt;</td>
        <td>Meta</td>
        <td>定义关于 HTML 文档的元信息。</td>
      </tr>
      <tr>
        <td>&lt; noframes&gt;</td>
        <td>Noframes</td>
        <td>定义针对不支持框架的用户的替代内容。</td>
      </tr>
      <tr>
        <td>&lt; noscript&gt;</td>
        <td>noscript</td>
        <td>定义针对不支持客户端脚本的用户的替代内容。(定义无脚本的节)</td>
      </tr>
      <tr>
        <td>&lt; object&gt;</td>
        <td>Object</td>
        <td>定义内嵌对象。</td>
      </tr>
      <tr>
        <td>&lt; ol&gt;</td>
        <td>Ordered list</td>
        <td>定义有序列表。</td>
      </tr>
      <tr>
        <td>&lt; optgroup&gt;</td>
        <td>option group</td>
        <td>定义选项组。</td>
      </tr>
      <tr>
        <td>&lt; option&gt;</td>
        <td>Option</td>
        <td>定义下拉列表的选项。</td>
      </tr>
      <tr>
        <td>&lt; p&gt;</td>
        <td>paragraph</td>
        <td>定义段落。</td>
      </tr>
      <tr>
        <td>&lt; param&gt;</td>
        <td>Param</td>
        <td>定义对象的参数。</td>
      </tr>
      <tr>
        <td>&lt; pre&gt;</td>
        <td>preformatted</td>
        <td>定义预格式文本。</td>
      </tr>
      <tr>
        <td>&lt; q&gt;</td>
        <td>quotation</td>
        <td>定义短的引用。</td>
      </tr>
      <tr>
        <td>&lt; s&gt;</td>
        <td></td>
        <td>不赞成使用。定义加删除线的文本。</td>
      </tr>
      <tr>
        <td>&lt; samp&gt;</td>
        <td>Sample</td>
        <td>定义计算机代码样本。</td>
      </tr>
      <tr>
        <td>&lt; script&gt;</td>
        <td>Script</td>
        <td>定义客户端脚本。</td>
      </tr>
      <tr>
        <td>&lt; select&gt;</td>
        <td>Select</td>
        <td>定义选择列表（下拉列表）。</td>
      </tr>
      <tr>
        <td>&lt; small&gt;</td>
        <td>Small</td>
        <td>定义小号文本。</td>
      </tr>
      <tr>
        <td>&lt; span&gt;</td>
        <td>Span</td>
        <td>定义文档中的节。</td>
      </tr>
      <tr>
        <td>&lt; strike&gt;</td>
        <td></td>
        <td>不赞成使用。定义加删除线文本。</td>
      </tr>
      <tr>
        <td>&lt; strong&gt;</td>
        <td>Strong</td>
        <td>定义强调文本。</td>
      </tr>
      <tr>
        <td>&lt; style&gt;</td>
        <td>Style</td>
        <td>定义文档的样式信息。</td>
      </tr>
      <tr>
        <td>&lt; sub&gt;</td>
        <td>Subscript</td>
        <td>定义下标文本。</td>
      </tr>
      <tr>
        <td>&lt; sup&gt;</td>
        <td>Superscript</td>
        <td>定义上标文本。</td>
      </tr>
      <tr>
        <td>&lt; table&gt;</td>
        <td>Table</td>
        <td>定义表格。</td>
      </tr>
      <tr>
        <td>&lt; tbody&gt;</td>
        <td>Table body</td>
        <td>定义表格中的主体内容。</td>
      </tr>
      <tr>
        <td>&lt; td&gt;</td>
        <td>Table data cell</td>
        <td>定义表格中的单元。</td>
      </tr>
      <tr>
        <td>&lt; textarea&gt;</td>
        <td>Textarea</td>
        <td>定义多行的文本输入控件。</td>
      </tr>
      <tr>
        <td>&lt; tfoot&gt;</td>
        <td>Table foot</td>
        <td>定义表格中的表注内容（脚注）。</td>
      </tr>
      <tr>
        <td>&lt; th&gt;</td>
        <td>Table head cell</td>
        <td>定义表格中的表头单元格。</td>
      </tr>
      <tr>
        <td>&lt; thead&gt;</td>
        <td>Table head</td>
        <td>定义表格中的表头内容。</td>
      </tr>
      <tr>
        <td>&lt; title&gt;</td>
        <td>Title</td>
        <td>定义文档的标题。</td>
      </tr>
      <tr>
        <td>&lt; tr&gt;</td>
        <td>Table row</td>
        <td>定义表格中的行。</td>
      </tr>
      <tr>
        <td>&lt; tt&gt;</td>
        <td>Teletype</td>
        <td>定义打字机文本。</td>
      </tr>
      <tr>
        <td>&lt; u&gt;</td>
        <td>Underline</td>
        <td>不赞成使用。定义下划线文本。</td>
      </tr>
      <tr>
        <td>&lt; ul&gt;</td>
        <td>Unordered list</td>
        <td>定义无序列表。</td>
      </tr>
      <tr>
        <td>&lt; var&gt;</td>
        <td>Variable</td>
        <td>定义文本的变量部分。</td>
      </tr>
      <tr>
        <td>&lt; xmp&gt;</td>
        <td></td>
        <td>不赞成使用。定义预格式文本。</td>
      </tr>
    </tbody>
  </table>
</body>
</html>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The definition of Component, Container, and Frame]]></title>
        <id>https://zy080080.github.io/post/h3kJtgJgp/</id>
        <link href="https://zy080080.github.io/post/h3kJtgJgp/">
        </link>
        <updated>2020-02-26T02:58:07.000Z</updated>
        <summary type="html"><![CDATA[<p>References from API</p>
]]></summary>
        <content type="html"><![CDATA[<p>References from API</p>
<!-- more -->
<ul>
<li>java.lang.Object
<ul>
<li>java.awt.Component
<ul>
<li>java.awt.Container
<ul>
<li>java.awt.Window
<ul>
<li>java.awt.Frame</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>A component is an object having a graphical representation that can be displayed on the screen and that can interact with the user. Examples of components are the buttons, checkboxes, and scrollbars of a typical graphical user interface.</p>
<p>A generic Abstract Window Toolkit(AWT) container object is a component that can contain other AWT components.</p>
<p>A Window object is a top-level window with no borders and no menubar. The default layout for a window is BorderLayout.<br>
A window must have either a frame, dialog, or another window defined as its owner when it's constructed.</p>
<p>A Frame is a top-level window with a title and a border.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scanner-java.util.NoSuchElementException]]></title>
        <id>https://zy080080.github.io/post/9KbTa6Jc8/</id>
        <link href="https://zy080080.github.io/post/9KbTa6Jc8/">
        </link>
        <updated>2020-01-17T17:45:54.000Z</updated>
        <content type="html"><![CDATA[<pre><code>package exceptionTest;

import java.util.Scanner;

public class ScannerExceptionTest {
    public static void main(String[] args) {
    	Scanner sc = new Scanner(System.in);

    	sc.close();

    	Scanner scan = new Scanner(System.in);
	    int num = scan.nextInt();
	    System.out.println(num);
    }
}
</code></pre>
<p>出现异常</p>
<pre><code>Exception in thread &quot;main&quot; java.util.NoSuchElementException
    at java.util.Scanner.throwFor(Scanner.java:862)
    at java.util.Scanner.next(Scanner.java:1485)
    at java.util.Scanner.nextInt(Scanner.java:2117)
    at java.util.Scanner.nextInt(Scanner.java:2076)
    at exceptionTest.ScannerExceptionTest.main(ScannerExceptionTest.java:12)
</code></pre>
<p>close()方法被调用时，导致标准输入System.in的关闭，<strong>关闭后无法再次打开</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程的状态转换图]]></title>
        <id>https://zy080080.github.io/post/9uq8XXg02/</id>
        <link href="https://zy080080.github.io/post/9uq8XXg02/">
        </link>
        <updated>2020-01-13T04:00:10.000Z</updated>
        <content type="html"><![CDATA[<p>Thread</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IO Stream总结]]></title>
        <id>https://zy080080.github.io/post/wgV5DncBt/</id>
        <link href="https://zy080080.github.io/post/wgV5DncBt/">
        </link>
        <updated>2019-12-07T15:25:56.000Z</updated>
        <summary type="html"><![CDATA[<p>IO流种类虽然多，但用法基本相同。</p>
]]></summary>
        <content type="html"><![CDATA[<p>IO流种类虽然多，但用法基本相同。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://zy080080.github.io//post-images/1575721507863.png" alt="" loading="lazy"></figure>
<h2 id="字节流">字节流</h2>
<h3 id="字节输入流">字节输入流</h3>
<h4 id="inputstream">InputStream</h4>
<ul>
<li>方法及子类
<ul>
<li>int read() : 一次读取一个字节</li>
<li>int read(byte[] bys) : 一次读取一个字节数组</li>
</ul>
</li>
<li>FileInputStream</li>
<li>BufferedInputStream</li>
</ul>
<h3 id="字节输出流">字节输出流</h3>
<h4 id="outputstream">OutputStream</h4>
<ul>
<li>方法及子类
<ul>
<li>void write(int by) : 一次写一个字节</li>
<li>void write(byte[] bys, int i, int len) : 一次写一个字节数组的一部分</li>
</ul>
</li>
<li>FileOutputStream</li>
<li>BufferedOutputStream</li>
</ul>
<h2 id="转换流">转换流</h2>
<ul>
<li>InputStreamReader(InputStream is)</li>
<li>OutputStreamWriter(OutputStream os)</li>
</ul>
<h2 id="字符流-字节流-编码表">字符流 = 字节流 + 编码表</h2>
<h3 id="字符输入流">字符输入流</h3>
<h4 id="reader">Reader</h4>
<ul>
<li>方法及子类
<ul>
<li>int read() : 一次读取一个字符</li>
<li>int read(char[] chs) : 一次读取一个字符数组</li>
</ul>
</li>
<li>InputStreamReader
<ul>
<li>FileReader</li>
</ul>
</li>
<li>BufferedReader
<ul>
<li>String readLine() : 一次读取一行数据</li>
</ul>
</li>
</ul>
<h3 id="字符输出流">字符输出流</h3>
<h4 id="writer">Writer</h4>
<ul>
<li>方法及子类
<ul>
<li>void write(int ch) : 一次写一个字符</li>
<li>void write(char[] chs, int i, int len) : 一次写一个字符数组的一部分</li>
</ul>
</li>
<li>OutputStreamWriter
<ul>
<li>FileWriter</li>
</ul>
</li>
<li>BufferedWriter
<ul>
<li>void newLine() : 写换行符号</li>
<li>void write(String s) : 写一个字符串</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机如何识别中文字符]]></title>
        <id>https://zy080080.github.io/post/7045yjWiy/</id>
        <link href="https://zy080080.github.io/post/7045yjWiy/">
        </link>
        <updated>2019-11-30T15:32:11.000Z</updated>
        <summary type="html"><![CDATA[<p>使用字节输入流将中文字符打印到控制台时往往无法识别，而使用字节流复制文件却可以完美显示，计算机是如何识别中文字符的呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用字节输入流将中文字符打印到控制台时往往无法识别，而使用字节流复制文件却可以完美显示，计算机是如何识别中文字符的呢？</p>
<!-- more -->
<pre><code>String str = &quot;中文输入&quot;;
byte[] by = str.getBytes();
System.out.println(by.toString());

//输出打印结果为[-28, -72, -83, -26, -106, -121, -24, -66, -109, -27, -123, -91]
</code></pre>
<p>遇到负数时，自动与下一个数拼接，得到中文字符。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[流的关闭方式]]></title>
        <id>https://zy080080.github.io/post/RtEn3DuwS/</id>
        <link href="https://zy080080.github.io/post/RtEn3DuwS/">
        </link>
        <updated>2019-11-15T14:13:12.000Z</updated>
        <summary type="html"><![CDATA[<p> 所有的流都应该在使用完毕后关闭。如果不关闭，会占用资源。</p>
]]></summary>
        <content type="html"><![CDATA[<p> 所有的流都应该在使用完毕后关闭。如果不关闭，会占用资源。</p>
<!-- more -->
<h2 id="在try中关闭">在try中关闭</h2>
<p> 有隐患。如果文件不存在或者在读取时出现异常，关闭流的方法不会被执行。 <strong>不推荐使用</strong></p>
<h2 id="在finally中关闭">在finally中关闭</h2>
<p> 这是标准的关闭流的方式。<br>
 在关闭时，需要进行一次try catch处理。<br>
 在写不重要的代码时可以采用try中关闭，不麻烦。</p>
<pre><code>try {
    FileOutputStream fos = new FileOutputStream(f);
    fos.write(data1);
    fos.write(data2);
    fos.write(data4);
    fos.write(data3);
    //fos.close();  
} catch (IOException e) {
    e.printStackTrace();
}finally {
    try {
        fos.close();
    }catch(IOException e) {
        e.printStackTrace();
    }
}
</code></pre>
<h2 id="使用try的方式">使用try()的方式</h2>
<p> 把流定义在try()里,try,catch或者finally结束的时候，会自动关闭。<br>
 这种编写代码的方式叫做 <mark>try-with-resources</mark>， 这是从JDK7开始支持的技术<br>
 所有的流，都实现了一个接口叫做 <mark>AutoCloseable</mark>，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。</p>
<pre><code>public static void main(String[] args) {
File f = new File(&quot;d:/lol.txt&quot;);

    //把流定义在try()里,try,catch或者finally结束的时候，会自动关闭
    try (FileInputStream fis = new FileInputStream(f)) {
        byte[] all = new byte[(int) f.length()];
        fis.read(all);
        for (byte b : all) {
            System.out.println(b);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[异常 Exception]]></title>
        <id>https://zy080080.github.io/post/jfUUCCexq/</id>
        <link href="https://zy080080.github.io/post/jfUUCCexq/">
        </link>
        <updated>2019-11-12T16:24:40.000Z</updated>
        <summary type="html"><![CDATA[<p>异常分为运行时异常（可查异常）和非运行时异常（不可查异常），他们的主要区别是……</p>
]]></summary>
        <content type="html"><![CDATA[<p>异常分为运行时异常（可查异常）和非运行时异常（不可查异常），他们的主要区别是……</p>
<!-- more -->
<h2 id="可查异常-checkedexception">可查异常 CheckedException</h2>
<p>可查异常是必须进行处理的异常，要么try catch住，要么往外抛，谁调用，谁处理，比如 FileNotFoundException。</p>
<p>如果不处理，<mark><strong>编译器就不让你通过</strong></mark></p>
<h2 id="运行时异常-runtimeexception">运行时异常 RuntimeException</h2>
<p>常见运行时异常（不可查异常）：</p>
<ul>
<li>除数不能为0异常 ArithmeticException</li>
<li>下标越界异常 ArrayIndexOutOfBoundsException</li>
<li>空指针异常 NullPointerException</li>
</ul>
<p>在编写代码的时候，依然可以使用try cathc throws进行处理，与可查异常（非运行时异常）不同之处在于：</p>
<ul>
<li>即使不进行try catch，也 <mark><strong>不会有编译错误</strong></mark></li>
</ul>
<p>Java之所以设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常<strong>太过于普遍</strong>，如果都需要进行捕捉，代码的可读性就会变得很糟。</p>
<h2 id="错误-error">错误 Error</h2>
<p>指的是系统级别的异常，通常是内存用光了。</p>
<blockquote>
<p>总结：</p>
<p>运行时异常与非运行时异常的最大区别是，运行时异常（不可查异常）不需要进行显式的捕捉，编译器会让你通过。</p>
<p>而非运行时异常（可查异常）需要进行显式的捕捉，不然编译器不会让你通过。</p>
</blockquote>
]]></content>
    </entry>
</feed>