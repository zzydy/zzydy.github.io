<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy080080.github.io/</id>
    <title>听故事的人</title>
    <updated>2020-01-17T14:05:53.019Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy080080.github.io/"/>
    <link rel="self" href="https://zy080080.github.io/atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://zy080080.github.io/images/avatar.png</logo>
    <icon>https://zy080080.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 听故事的人</rights>
    <entry>
        <title type="html"><![CDATA[Scanner-java.util.NoSuchElementException]]></title>
        <id>https://zy080080.github.io/post/9KbTa6Jc8</id>
        <link href="https://zy080080.github.io/post/9KbTa6Jc8">
        </link>
        <updated>2020-01-17T14:45:54.000Z</updated>
        <content type="html"><![CDATA[<pre><code>import java.util.Scanner;

public class ScannerExceptionTest {
    public static void main(String[] args) {
	Scanner sc = new Scanner(System.in);

    	sc.close();

    	Scanner scan = new Scanner(System.in);
	    int num = scan.nextInt();
	    System.out.println(num);	
    }
}
</code></pre>
<p>出现异常</p>
<pre><code>Exception in thread &quot;main&quot; java.util.NoSuchElementException
at java.util.Scanner.throwFor(Scanner.java:862)
at java.util.Scanner.next(Scanner.java:1485)
at java.util.Scanner.nextInt(Scanner.java:2117)
at java.util.Scanner.nextInt(Scanner.java:2076)
at exceptionTest.ScannerExceptionTest.main(ScannerExceptionTest.java:12)
</code></pre>
<p>close()方法被调用时，导致标准输入System.in的关闭，<strong>关闭后无法再次打开</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程的状态转换图]]></title>
        <id>https://zy080080.github.io/post/9uq8XXg02</id>
        <link href="https://zy080080.github.io/post/9uq8XXg02">
        </link>
        <updated>2020-01-13T03:00:10.000Z</updated>
        <content type="html"><![CDATA[<p>Thread</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IO Stream总结]]></title>
        <id>https://zy080080.github.io/post/wgV5DncBt</id>
        <link href="https://zy080080.github.io/post/wgV5DncBt">
        </link>
        <updated>2019-12-07T14:25:56.000Z</updated>
        <summary type="html"><![CDATA[<p>IO流种类虽然多，但用法基本相同。</p>
]]></summary>
        <content type="html"><![CDATA[<p>IO流种类虽然多，但用法基本相同。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://zy080080.github.io//post-images/1575721507863.png" alt="" loading="lazy"></figure>
<h2 id="字节流">字节流</h2>
<h3 id="字节输入流">字节输入流</h3>
<h4 id="inputstream">InputStream</h4>
<ul>
<li>方法及子类
<ul>
<li>int read() : 一次读取一个字节</li>
<li>int read(byte[] bys) : 一次读取一个字节数组</li>
</ul>
</li>
<li>FileInputStream</li>
<li>BufferedInputStream</li>
</ul>
<h3 id="字节输出流">字节输出流</h3>
<h4 id="outputstream">OutputStream</h4>
<ul>
<li>方法及子类
<ul>
<li>void write(int by) : 一次写一个字节</li>
<li>void write(byte[] bys, int i, int len) : 一次写一个字节数组的一部分</li>
</ul>
</li>
<li>FileOutputStream</li>
<li>BufferedOutputStream</li>
</ul>
<h2 id="转换流">转换流</h2>
<ul>
<li>InputStreamReader(InputStream is)</li>
<li>OutputStreamWriter(OutputStream os)</li>
</ul>
<h2 id="字符流-字节流-编码表">字符流 = 字节流 + 编码表</h2>
<h3 id="字符输入流">字符输入流</h3>
<h4 id="reader">Reader</h4>
<ul>
<li>方法及子类
<ul>
<li>int read() : 一次读取一个字符</li>
<li>int read(char[] chs) : 一次读取一个字符数组</li>
</ul>
</li>
<li>InputStreamReader
<ul>
<li>FileReader</li>
</ul>
</li>
<li>BufferedReader
<ul>
<li>String readLine() : 一次读取一行数据</li>
</ul>
</li>
</ul>
<h3 id="字符输出流">字符输出流</h3>
<h4 id="writer">Writer</h4>
<ul>
<li>方法及子类
<ul>
<li>void write(int ch) : 一次写一个字符</li>
<li>void write(char[] chs, int i, int len) : 一次写一个字符数组的一部分</li>
</ul>
</li>
<li>OutputStreamWriter
<ul>
<li>FileWriter</li>
</ul>
</li>
<li>BufferedWriter
<ul>
<li>void newLine() : 写换行符号</li>
<li>void write(String s) : 写一个字符串</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机如何识别中文字符]]></title>
        <id>https://zy080080.github.io/post/7045yjWiy</id>
        <link href="https://zy080080.github.io/post/7045yjWiy">
        </link>
        <updated>2019-11-30T14:32:11.000Z</updated>
        <summary type="html"><![CDATA[<p>使用字节输入流将中文字符打印到控制台时往往无法识别，而使用字节流复制文件却可以完美显示，计算机是如何识别中文字符的呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用字节输入流将中文字符打印到控制台时往往无法识别，而使用字节流复制文件却可以完美显示，计算机是如何识别中文字符的呢？</p>
<!-- more -->
<pre><code>String str = &quot;中文输入&quot;;
byte[] by = str.getBytes();
System.out.println(by.toString());

//输出打印结果为[-28, -72, -83, -26, -106, -121, -24, -66, -109, -27, -123, -91]
</code></pre>
<p>遇到负数时，自动与下一个数拼接，得到中文字符。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[流的关闭方式]]></title>
        <id>https://zy080080.github.io/post/RtEn3DuwS</id>
        <link href="https://zy080080.github.io/post/RtEn3DuwS">
        </link>
        <updated>2019-11-15T13:13:12.000Z</updated>
        <summary type="html"><![CDATA[<p> 所有的流都应该在使用完毕后关闭。如果不关闭，会占用资源。</p>
]]></summary>
        <content type="html"><![CDATA[<p> 所有的流都应该在使用完毕后关闭。如果不关闭，会占用资源。</p>
<!-- more -->
<h2 id="在try中关闭">在try中关闭</h2>
<p> 有隐患。如果文件不存在或者在读取时出现异常，关闭流的方法不会被执行。 <strong>不推荐使用</strong></p>
<h2 id="在finally中关闭">在finally中关闭</h2>
<p> 这是标准的关闭流的方式。<br>
 在关闭时，需要进行一次try catch处理。<br>
 在写不重要的代码时可以采用try中关闭，不麻烦。</p>
<pre><code>try {
    FileOutputStream fos = new FileOutputStream(f);
    fos.write(data1);
    fos.write(data2);
    fos.write(data4);
    fos.write(data3);
    //fos.close();  
} catch (IOException e) {
    e.printStackTrace();
}finally {
    try {
        fos.close();
    }catch(IOException e) {
        e.printStackTrace();
    }
}
</code></pre>
<h2 id="使用try的方式">使用try()的方式</h2>
<p> 把流定义在try()里,try,catch或者finally结束的时候，会自动关闭。<br>
 这种编写代码的方式叫做 <mark>try-with-resources</mark>， 这是从JDK7开始支持的技术<br>
 所有的流，都实现了一个接口叫做 <mark>AutoCloseable</mark>，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。</p>
<pre><code>public static void main(String[] args) {
File f = new File(&quot;d:/lol.txt&quot;);

    //把流定义在try()里,try,catch或者finally结束的时候，会自动关闭
    try (FileInputStream fis = new FileInputStream(f)) {
        byte[] all = new byte[(int) f.length()];
        fis.read(all);
        for (byte b : all) {
            System.out.println(b);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[异常 Exception]]></title>
        <id>https://zy080080.github.io/post/jfUUCCexq</id>
        <link href="https://zy080080.github.io/post/jfUUCCexq">
        </link>
        <updated>2019-11-12T15:24:40.000Z</updated>
        <summary type="html"><![CDATA[<p>异常分为运行时异常（可查异常）和非运行时异常（不可查异常），他们的主要区别是……</p>
]]></summary>
        <content type="html"><![CDATA[<p>异常分为运行时异常（可查异常）和非运行时异常（不可查异常），他们的主要区别是……</p>
<!-- more -->
<h2 id="可查异常-checkedexception">可查异常 CheckedException</h2>
<p>可查异常是必须进行处理的异常，要么try catch住，要么往外抛，谁调用，谁处理，比如 FileNotFoundException。</p>
<p>如果不处理，<mark><strong>编译器就不让你通过</strong></mark></p>
<h2 id="运行时异常-runtimeexception">运行时异常 RuntimeException</h2>
<p>常见运行时异常（不可查异常）：</p>
<ul>
<li>除数不能为0异常 ArithmeticException</li>
<li>下标越界异常 ArrayIndexOutOfBoundsException</li>
<li>空指针异常 NullPointerException</li>
</ul>
<p>在编写代码的时候，依然可以使用try cathc throws进行处理，与可查异常（非运行时异常）不同之处在于：</p>
<ul>
<li>即使不进行try catch，也 <mark><strong>不会有编译错误</strong></mark></li>
</ul>
<p>Java之所以设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常<strong>太过于普遍</strong>，如果都需要进行捕捉，代码的可读性就会变得很糟。</p>
<h2 id="错误-error">错误 Error</h2>
<p>指的是系统级别的异常，通常是内存用光了。</p>
<blockquote>
<p>总结：</p>
<p>运行时异常与非运行时异常的最大区别是，运行时异常（不可查异常）不需要进行显式的捕捉，编译器会让你通过。</p>
<p>而非运行时异常（可查异常）需要进行显式的捕捉，不然编译器不会让你通过。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ラズベリーパイ 4Bが起動しない時の対応法]]></title>
        <id>https://zy080080.github.io/post/1tSysQNzy</id>
        <link href="https://zy080080.github.io/post/1tSysQNzy">
        </link>
        <updated>2019-10-06T03:00:08.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a></p>
<!-- more -->
<p>ラズベリーパイを手に入れてからすぐにNOOBSでインストールしてみたが、起動できませんでした。<br>
そしてシステムを直接SDカードにインストールするのも試しましたが、同じく赤いLEDだけが点灯して、起動が失敗しました。</p>
<p>まだラズパイ４Bに関してネット上に乗っている情報が少ないですが、公式Webページから対応法が見つかりました。</p>
<blockquote>
<p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br>
If your Raspberry Pi 4 will not boot, it is possible that the SPI EEPROM has become corrupted.<br>
To check, remove the SD card, disconnect the device from power, then reconnect it. If the green LED does not flash, you will need to reprogram the EEPROM:</p>
<ul>
<li>Download the bootloader</li>
<li>Extract it to an empty FAT-formatted SD card and insert it into your Raspberry Pi 4</li>
<li>Connect the power and wait for the green LED to flash quickly</li>
</ul>
<p>Notes:</p>
<ul>
<li>The updated bootloader improves compatibility with HATs by changing the behaviour of HALT to keep the 3V3 pin powered (view the full bootloader release notes)</li>
<li>The previous bootloader remains available for download</li>
</ul>
</blockquote>
<p>やっぱり英語は大切ですね。。。。</p>
<p>ちなみに、SDカードをカードリーダに入れてUSBとしてラズパイに差し込んだ人もいたらしいですが、ちゃんと裏面にセットすれば問題ないはずです。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[A solution of unable to boot up Raspberry Pi 4B]]></title>
        <id>https://zy080080.github.io/post/dgAVKMhPS</id>
        <link href="https://zy080080.github.io/post/dgAVKMhPS">
        </link>
        <updated>2019-10-05T21:26:46.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
<!-- more -->
<p> I received my new Raspberry Pi yesterday. I tried to boot up the Pi in two ways, but it couldn't be boot.<br>
 At last, I found the solution on its homepage:</p>
<blockquote>
<p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br>
If your Raspberry Pi 4 will not boot, it is possible that the SPI EEPROM has become corrupted.<br>
To check, remove the SD card, disconnect the device from power, then reconnect it. If the green LED does not flash, you will need to reprogram the EEPROM:</p>
<ul>
<li>Download the bootloader</li>
<li>Extract it to an empty FAT-formatted SD card and insert it into your Raspberry Pi 4</li>
<li>Connect the power and wait for the green LED to flash quickly</li>
</ul>
<p>Notes:</p>
<ul>
<li>The updated bootloader improves compatibility with HATs by changing the behaviour of HALT to keep the 3V3 pin powered (view the full bootloader release notes)</li>
<li>The previous bootloader remains available for download</li>
</ul>
</blockquote>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决无法启动树莓派4B的问题]]></title>
        <id>https://zy080080.github.io/post/pE2JY0ig0</id>
        <link href="https://zy080080.github.io/post/pE2JY0ig0">
        </link>
        <updated>2019-10-05T16:34:08.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
<!-- more -->
<p> 昨天从日亚买的树莓派4B到货了，但是按网上说的无论是用NOOBS还是直接装系统都无法正常启动，一直处于红灯常亮状态。<br>
 找了半天相关消息都比较少，直到从官网看到：</p>
<blockquote>
<p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br>
If your Raspberry Pi 4 will not boot, it is possible that the SPI EEPROM has become corrupted.<br>
To check, remove the SD card, disconnect the device from power, then reconnect it. If the green LED does not flash, you will need to reprogram the EEPROM:</p>
<ul>
<li>Download the bootloader</li>
<li>Extract it to an empty FAT-formatted SD card and insert it into your Raspberry Pi 4</li>
<li>Connect the power and wait for the green LED to flash quickly</li>
</ul>
<p>Notes:</p>
<ul>
<li>The updated bootloader improves compatibility with HATs by changing the behaviour of HALT to keep the 3V3 pin powered (view the full bootloader release notes)</li>
<li>The previous bootloader remains available for download</li>
</ul>
</blockquote>
<p> 按照这个将下载的bootloader装进SD卡启动直到绿灯闪烁后，再次装NOOBS或者Raspbian系统，问题才得以解决。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Does Java pass by reference or pass by value?]]></title>
        <id>https://zy080080.github.io/post/fFi1CAqNV</id>
        <link href="https://zy080080.github.io/post/fFi1CAqNV">
        </link>
        <updated>2019-09-15T16:46:51.000Z</updated>
        <summary type="html"><![CDATA[<p>Source：<a href="https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html">https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>Source：<a href="https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html">https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html</a></p>
<!-- more -->
<p><a href="https://zy080080.github.io/post/UYqd_tZ7B/">点此查看相关中文文章</a></p>
<h2 id="q-learn-java-if-java-uses-the-pass-by-reference-why-wont-a-swap-function-work">Q: Learn Java: If Java uses the pass-by reference, why won't a swap function work?</h2>
<p>A: Java does manipulate objects by reference, and all object variables are references. However, Java doesn't pass method arguments by reference; it passes them by value.</p>
<p>Take the badSwap() method for example:</p>
<pre><code>public void badSwap(int var1, int var2)
{
 int temp = var1;
 var1 = var2;
 var2 = temp;
}
</code></pre>
<p>When badSwap() returns, the variables passed as arguments will still hold their original values. The method will also fail if we change the arguments type from int to Object, since Java passes object references by value as well. Now, here is where it gets tricky:</p>
<pre><code>public void tricky(Point arg1, Point arg2)
{
 arg1.x = 100;
 arg1.y = 100;
 Point temp = arg1;
 arg1 = arg2;
 arg2 = temp;
}
public static void main(String [] args)
{
 Point pnt1 = new Point(0,0);
 Point pnt2 = new Point(0,0);
 System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y: &quot; +pnt1.y); 
 System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);
 System.out.println(&quot; &quot;);
 tricky(pnt1,pnt2);
 System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y:&quot; + pnt1.y); 
 System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);  
}
</code></pre>
<p>If we execute this main() method, we see the following output:</p>
<pre><code>X: 0 Y: 0
X: 0 Y: 0
X: 100 Y: 100
X: 0 Y: 0
</code></pre>
<p>The method successfully alters the value of pnt1, even though it is passed by value; however, a swap of pnt1 and pnt2 fails! This is the major source of confusion. In the main() method, pnt1 and pnt2 are nothing more than object references. When you pass pnt1 and pnt2 to the tricky() method, Java passes the references by value just like any other parameter. This means the references passed to the method are actually copies of the original references. Figure 1 below shows two references pointing to the same object after Java passes an object to a method.</p>
<figure data-type="image" tabindex="1"><img src="https://images.techhive.com/images/idge/imported/article/jvw/2000/05/03-qa-0512-pass1-100158781-orig.gif" alt="Figure 1. After being passed to a method, an object will have at least two references" loading="lazy"></figure>
<p>Java copies and passes the reference by value, not the object. Thus, method manipulation will alter the objects, since the references point to the original objects. But since the references are copies, swaps will fail. As Figure 2 illustrates, the method references swap, but not the original references. Unfortunately, after a method call, you are left with only the unswapped original references. For a swap to succeed outside of the method call, we need to swap the original references, not the copies.</p>
<p>O'Reilly's Java in a Nutshell by David Flanagan (see Resources) puts it best: &quot;Java manipulates objects 'by reference,' but it passes object references to methods 'by value.'&quot; As a result, you cannot write a standard swap method to swap objects.</p>
]]></content>
    </entry>
</feed>