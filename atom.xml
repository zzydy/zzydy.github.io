<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy080080.github.io/</id>
    <title>听故事的人</title>
    <updated>2019-12-07T12:26:54.916Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy080080.github.io/"/>
    <link rel="self" href="https://zy080080.github.io//atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://zy080080.github.io//images/avatar.png</logo>
    <icon>https://zy080080.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 听故事的人</rights>
    <entry>
        <title type="html"><![CDATA[IO Stream总结]]></title>
        <id>https://zy080080.github.io//post/wgV5DncBt</id>
        <link href="https://zy080080.github.io//post/wgV5DncBt">
        </link>
        <updated>2019-12-07T13:25:56.000Z</updated>
        <summary type="html"><![CDATA[<p>IO流种类虽然多，但用法基本相同。</p>
]]></summary>
        <content type="html"><![CDATA[<p>IO流种类虽然多，但用法基本相同。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://zy080080.github.io//post-images/1575721507863.png" alt=""></figure>
<h2 id="字节流">字节流</h2>
<h3 id="字节输入流">字节输入流</h3>
<h4 id="inputstream">InputStream</h4>
<ul>
<li>方法及子类
<ul>
<li>int read() : 一次读取一个字节</li>
<li>int read(byte[] bys) : 一次读取一个字节数组</li>
</ul>
</li>
<li>FileInputStream</li>
<li>BufferedInputStream</li>
</ul>
<h3 id="字节输出流">字节输出流</h3>
<h4 id="outputstream">OutputStream</h4>
<ul>
<li>方法及子类
<ul>
<li>void write(int by) : 一次写一个字节</li>
<li>void write(byte[] bys, int i, int len) : 一次写一个字节数组的一部分</li>
</ul>
</li>
<li>FileOutputStream</li>
<li>BufferedOutputStream</li>
</ul>
<h2 id="转换流">转换流</h2>
<ul>
<li>InputStreamReader(InputStream is)</li>
<li>OutputStreamWriter(OutputStream os)</li>
</ul>
<h2 id="字符流-字节流-编码表">字符流 = 字节流 + 编码表</h2>
<h3 id="字符输入流">字符输入流</h3>
<h4 id="reader">Reader</h4>
<ul>
<li>方法及子类
<ul>
<li>int read() : 一次读取一个字符</li>
<li>int read(char[] chs) : 一次读取一个字符数组</li>
</ul>
</li>
<li>InputStreamReader
<ul>
<li>FileReader</li>
</ul>
</li>
<li>BufferedReader
<ul>
<li>String readLine() : 一次读取一行数据</li>
</ul>
</li>
</ul>
<h3 id="字符输出流">字符输出流</h3>
<h4 id="writer">Writer</h4>
<ul>
<li>方法及子类
<ul>
<li>void write(int ch) : 一次写一个字符</li>
<li>void write(char[] chs, int i, int len) : 一次写一个字符数组的一部分</li>
</ul>
</li>
<li>OutputStreamWriter
<ul>
<li>FileWriter</li>
</ul>
</li>
<li>BufferedWriter
<ul>
<li>void newLine() : 写换行符号</li>
<li>void write(String s) : 写一个字符串</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机如何识别中文字符]]></title>
        <id>https://zy080080.github.io//post/7045yjWiy</id>
        <link href="https://zy080080.github.io//post/7045yjWiy">
        </link>
        <updated>2019-11-30T14:32:11.000Z</updated>
        <summary type="html"><![CDATA[<p>使用字节输入流将中文字符打印到控制台时往往无法识别，而使用字节流复制文件却可以完美显示，计算机是如何识别中文字符的呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用字节输入流将中文字符打印到控制台时往往无法识别，而使用字节流复制文件却可以完美显示，计算机是如何识别中文字符的呢？</p>
<!-- more -->
<pre><code>String str = &quot;中文输入&quot;;
byte[] by = str.getBytes();
System.out.println(by.toString());

//输出打印结果为[-28, -72, -83, -26, -106, -121, -24, -66, -109, -27, -123, -91]
</code></pre>
<p>遇到负数时，自动与下一个数拼接，得到中文字符。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[流的关闭方式]]></title>
        <id>https://zy080080.github.io//post/RtEn3DuwS</id>
        <link href="https://zy080080.github.io//post/RtEn3DuwS">
        </link>
        <updated>2019-11-15T13:13:12.000Z</updated>
        <summary type="html"><![CDATA[<p> 所有的流都应该在使用完毕后关闭。如果不关闭，会占用资源。</p>
]]></summary>
        <content type="html"><![CDATA[<p> 所有的流都应该在使用完毕后关闭。如果不关闭，会占用资源。</p>
<!-- more -->
<h2 id="在try中关闭">在try中关闭</h2>
<p> 有隐患。如果文件不存在或者在读取时出现异常，关闭流的方法不会被执行。 <strong>不推荐使用</strong></p>
<h2 id="在finally中关闭">在finally中关闭</h2>
<p> 这是标准的关闭流的方式。<br>
 在关闭时，需要进行一次try catch处理。<br>
 在写不重要的代码时可以采用try中关闭，不麻烦。</p>
<pre><code>try {
    FileOutputStream fos = new FileOutputStream(f);
    fos.write(data1);
    fos.write(data2);
    fos.write(data4);
    fos.write(data3);
    //fos.close();  
} catch (IOException e) {
    e.printStackTrace();
}finally {
    try {
        fos.close();
    }catch(IOException e) {
        e.printStackTrace();
    }
}
</code></pre>
<h2 id="使用try的方式">使用try()的方式</h2>
<p> 把流定义在try()里,try,catch或者finally结束的时候，会自动关闭。<br>
 这种编写代码的方式叫做 <mark>try-with-resources</mark>， 这是从JDK7开始支持的技术<br>
 所有的流，都实现了一个接口叫做 <mark>AutoCloseable</mark>，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。</p>
<pre><code>public static void main(String[] args) {
File f = new File(&quot;d:/lol.txt&quot;);

    //把流定义在try()里,try,catch或者finally结束的时候，会自动关闭
    try (FileInputStream fis = new FileInputStream(f)) {
        byte[] all = new byte[(int) f.length()];
        fis.read(all);
        for (byte b : all) {
            System.out.println(b);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[异常 Exception]]></title>
        <id>https://zy080080.github.io//post/jfUUCCexq</id>
        <link href="https://zy080080.github.io//post/jfUUCCexq">
        </link>
        <updated>2019-11-12T15:24:40.000Z</updated>
        <summary type="html"><![CDATA[<p>异常分为运行时异常（可查异常）和非运行时异常（不可查异常），他们的主要区别是……</p>
]]></summary>
        <content type="html"><![CDATA[<p>异常分为运行时异常（可查异常）和非运行时异常（不可查异常），他们的主要区别是……</p>
<!-- more -->
<h2 id="可查异常-checkedexception">可查异常 CheckedException</h2>
<p>可查异常是必须进行处理的异常，要么try catch住，要么往外抛，谁调用，谁处理，比如 FileNotFoundException。</p>
<p>如果不处理，<mark><strong>编译器就不让你通过</strong></mark></p>
<h2 id="运行时异常-runtimeexception">运行时异常 RuntimeException</h2>
<p>常见运行时异常（不可查异常）：</p>
<ul>
<li>除数不能为0异常 ArithmeticException</li>
<li>下标越界异常 ArrayIndexOutOfBoundsException</li>
<li>空指针异常 NullPointerException</li>
</ul>
<p>在编写代码的时候，依然可以使用try cathc throws进行处理，与可查异常（非运行时异常）不同之处在于：</p>
<ul>
<li>即使不进行try catch，也 <mark><strong>不会有编译错误</strong></mark></li>
</ul>
<p>Java之所以设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常<strong>太过于普遍</strong>，如果都需要进行捕捉，代码的可读性就会变得很糟。</p>
<h2 id="错误-error">错误 Error</h2>
<p>指的是系统级别的异常，通常是内存用光了。</p>
<blockquote>
<p>总结：</p>
<p>运行时异常与非运行时异常的最大区别是，运行时异常（不可查异常）不需要进行显式的捕捉，编译器会让你通过。</p>
<p>而非运行时异常（可查异常）需要进行显式的捕捉，不然编译器不会让你通过。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ラズベリーパイ 4Bが起動しない時の対応法]]></title>
        <id>https://zy080080.github.io//post/1tSysQNzy</id>
        <link href="https://zy080080.github.io//post/1tSysQNzy">
        </link>
        <updated>2019-10-06T03:00:08.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a></p>
<!-- more -->
<p>ラズベリーパイを手に入れてからすぐにNOOBSでインストールしてみたが、起動できませんでした。<br>
そしてシステムを直接SDカードにインストールするのも試しましたが、同じく赤いLEDだけが点灯して、起動が失敗しました。</p>
<p>まだラズパイ４Bに関してネット上に乗っている情報が少ないですが、公式Webページから対応法が見つかりました。</p>
<blockquote>
<p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br>
If your Raspberry Pi 4 will not boot, it is possible that the SPI EEPROM has become corrupted.<br>
To check, remove the SD card, disconnect the device from power, then reconnect it. If the green LED does not flash, you will need to reprogram the EEPROM:</p>
<ul>
<li>Download the bootloader</li>
<li>Extract it to an empty FAT-formatted SD card and insert it into your Raspberry Pi 4</li>
<li>Connect the power and wait for the green LED to flash quickly</li>
</ul>
<p>Notes:</p>
<ul>
<li>The updated bootloader improves compatibility with HATs by changing the behaviour of HALT to keep the 3V3 pin powered (view the full bootloader release notes)</li>
<li>The previous bootloader remains available for download</li>
</ul>
</blockquote>
<p>やっぱり英語は大切ですね。。。。</p>
<p>ちなみに、SDカードをカードリーダに入れてUSBとしてラズパイに差し込んだ人もいたらしいですが、ちゃんと裏面にセットすれば問題ないはずです。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[A solution of unable to boot up Raspberry Pi 4B]]></title>
        <id>https://zy080080.github.io//post/dgAVKMhPS</id>
        <link href="https://zy080080.github.io//post/dgAVKMhPS">
        </link>
        <updated>2019-10-05T21:26:46.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
<!-- more -->
<p> I received my new Raspberry Pi yesterday. I tried to boot up the Pi in two ways, but it couldn't be boot.<br>
 At last, I found the solution on its homepage:</p>
<blockquote>
<p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br>
If your Raspberry Pi 4 will not boot, it is possible that the SPI EEPROM has become corrupted.<br>
To check, remove the SD card, disconnect the device from power, then reconnect it. If the green LED does not flash, you will need to reprogram the EEPROM:</p>
<ul>
<li>Download the bootloader</li>
<li>Extract it to an empty FAT-formatted SD card and insert it into your Raspberry Pi 4</li>
<li>Connect the power and wait for the green LED to flash quickly</li>
</ul>
<p>Notes:</p>
<ul>
<li>The updated bootloader improves compatibility with HATs by changing the behaviour of HALT to keep the 3V3 pin powered (view the full bootloader release notes)</li>
<li>The previous bootloader remains available for download</li>
</ul>
</blockquote>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决无法启动树莓派4B的问题]]></title>
        <id>https://zy080080.github.io//post/pE2JY0ig0</id>
        <link href="https://zy080080.github.io//post/pE2JY0ig0">
        </link>
        <updated>2019-10-05T16:34:08.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
<!-- more -->
<p> 昨天从日亚买的树莓派4B到货了，但是按网上说的无论是用NOOBS还是直接装系统都无法正常启动，一直处于红灯常亮状态。<br>
 找了半天相关消息都比较少，直到从官网看到：</p>
<blockquote>
<p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br>
If your Raspberry Pi 4 will not boot, it is possible that the SPI EEPROM has become corrupted.<br>
To check, remove the SD card, disconnect the device from power, then reconnect it. If the green LED does not flash, you will need to reprogram the EEPROM:</p>
<ul>
<li>Download the bootloader</li>
<li>Extract it to an empty FAT-formatted SD card and insert it into your Raspberry Pi 4</li>
<li>Connect the power and wait for the green LED to flash quickly</li>
</ul>
<p>Notes:</p>
<ul>
<li>The updated bootloader improves compatibility with HATs by changing the behaviour of HALT to keep the 3V3 pin powered (view the full bootloader release notes)</li>
<li>The previous bootloader remains available for download</li>
</ul>
</blockquote>
<p> 按照这个将下载的bootloader装进SD卡启动直到绿灯闪烁后，再次装NOOBS或者Raspbian系统，问题才得以解决。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Does Java pass by reference or pass by value?]]></title>
        <id>https://zy080080.github.io//post/fFi1CAqNV</id>
        <link href="https://zy080080.github.io//post/fFi1CAqNV">
        </link>
        <updated>2019-09-15T16:46:51.000Z</updated>
        <summary type="html"><![CDATA[<p>Source：<a href="https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html">https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>Source：<a href="https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html">https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html</a></p>
<!-- more -->
<p><a href="https://zy080080.github.io/post/UYqd_tZ7B/">点此查看相关中文文章</a></p>
<h2 id="q-learn-java-if-java-uses-the-pass-by-reference-why-wont-a-swap-function-work">Q: Learn Java: If Java uses the pass-by reference, why won't a swap function work?</h2>
<p>A: Java does manipulate objects by reference, and all object variables are references. However, Java doesn't pass method arguments by reference; it passes them by value.</p>
<p>Take the badSwap() method for example:</p>
<pre><code>public void badSwap(int var1, int var2)
{
 int temp = var1;
 var1 = var2;
 var2 = temp;
}
</code></pre>
<p>When badSwap() returns, the variables passed as arguments will still hold their original values. The method will also fail if we change the arguments type from int to Object, since Java passes object references by value as well. Now, here is where it gets tricky:</p>
<pre><code>public void tricky(Point arg1, Point arg2)
{
 arg1.x = 100;
 arg1.y = 100;
 Point temp = arg1;
 arg1 = arg2;
 arg2 = temp;
}
public static void main(String [] args)
{
 Point pnt1 = new Point(0,0);
 Point pnt2 = new Point(0,0);
 System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y: &quot; +pnt1.y); 
 System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);
 System.out.println(&quot; &quot;);
 tricky(pnt1,pnt2);
 System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y:&quot; + pnt1.y); 
 System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);  
}
</code></pre>
<p>If we execute this main() method, we see the following output:</p>
<pre><code>X: 0 Y: 0
X: 0 Y: 0
X: 100 Y: 100
X: 0 Y: 0
</code></pre>
<p>The method successfully alters the value of pnt1, even though it is passed by value; however, a swap of pnt1 and pnt2 fails! This is the major source of confusion. In the main() method, pnt1 and pnt2 are nothing more than object references. When you pass pnt1 and pnt2 to the tricky() method, Java passes the references by value just like any other parameter. This means the references passed to the method are actually copies of the original references. Figure 1 below shows two references pointing to the same object after Java passes an object to a method.</p>
<figure data-type="image" tabindex="1"><img src="https://images.techhive.com/images/idge/imported/article/jvw/2000/05/03-qa-0512-pass1-100158781-orig.gif" alt="Figure 1. After being passed to a method, an object will have at least two references"></figure>
<p>Java copies and passes the reference by value, not the object. Thus, method manipulation will alter the objects, since the references point to the original objects. But since the references are copies, swaps will fail. As Figure 2 illustrates, the method references swap, but not the original references. Unfortunately, after a method call, you are left with only the unswapped original references. For a swap to succeed outside of the method call, we need to swap the original references, not the copies.</p>
<p>O'Reilly's Java in a Nutshell by David Flanagan (see Resources) puts it best: &quot;Java manipulates objects 'by reference,' but it passes object references to methods 'by value.'&quot; As a result, you cannot write a standard swap method to swap objects.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编语言笔记（第三章）]]></title>
        <id>https://zy080080.github.io//post/lwMS0nfZZ</id>
        <link href="https://zy080080.github.io//post/lwMS0nfZZ">
        </link>
        <updated>2019-09-13T03:39:41.000Z</updated>
        <summary type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
]]></summary>
        <content type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
<!-- more -->
<h1 id="第三章-寄存器内存访问">第三章 寄存器（内存访问）</h1>
<h2 id="31-内存中字的存储">3.1 内存中字的存储</h2>
<p> CPU中用16位寄存器来存储一个字，高8位存放高位字节，低8位存放低位字节，在内存中储存时，由于内存单元是字节单元（一个字节存放一个单元），则一个字要用两个地址连续的内存单元来存放。</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>20H</td>
</tr>
<tr>
<td>1</td>
<td>4EH</td>
</tr>
<tr>
<td>2</td>
<td>12H</td>
</tr>
<tr>
<td>4</td>
<td>00H</td>
</tr>
<tr>
<td>5</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
</tr>
</tbody>
</table>
<p> 如表格，我们用0，1两个内存单元存放数据20000（4E20H）。4E20H的低位字节存放在0号单元中，高位字节存放在1号单元中。这两个内存单元可以看做一个起始地址为0的字单元（存放一个字的内存单元，由0、1两个字节单元组成）。数据18（0012H）同理。</p>
<h3 id="我们将起始地址为n的字单元简称为n地址字单元-比如一个字单元有2-3两个内存单元组成则这个字单元的起始地址为2我们可以说这是2地址字单元"> <strong>我们将起始地址为N的字单元简称为N地址字单元。比如一个字单元有2、3两个内存单元组成，则这个字单元的起始地址为2，我们可以说这是2地址字单元</strong></h3>
<h2 id="32-ds和adress">3.2 DS和[adress]</h2>
<p> CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086CPU中，内存地址由段地址和偏移地址组成。8086CPU中有个DS寄存器，通常用来存放要访问数据的段地址。比如我们要读取10000H单元的内容，可以用如下的程序段进行：</p>
<p>mov bx,1000H<br>
mov ds,bx<br>
mov al,[0]</p>
<p> 上面的三条指令将10000H（1000：0）中的数据读到al中<br>
 mov指令可以将一个内存单元中的内容送入一个寄存器中，内存单元需要用内存单元的地址来指明。格式为 mov 寄存器名，内存单元地址。<br>
 “[···]“表示一个内存单元，其中的内容表示内存单元的偏移地址。而段地址存储在DS寄存器中。<br>
 DS是一个段寄存器，8086CPU不支持将数据直接从入段寄存器的操作。 mov ds，1000H <strong>是非法的</strong></p>
<p> 数据还可以从寄存器送入内存单元，如：</p>
<pre><code>mov bx,1000H
mov ds,bx 
mov [0],al
</code></pre>
<h2 id="33-字的传送">3.3 字的传送</h2>
<p> 8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据，即一次性传送一个字。</p>
<pre><code>mov ax,1000H
mov ds,bx
mov ax,[0] //1000:0 处的字形数据送入ax
mov [0],cx //cx中的16位数据送到 1000:0 处
</code></pre>
<blockquote>
<p>注意：传送到ax，bx，cx的是字形数据，传送到al，ah，bl，bh的是字节型数据。</p>
</blockquote>
<h2 id="34-mov-add-sub指令">3.4 mov、add、sub指令</h2>
<p> 到现在，我们知道mov指令可以有以下几种形式：</p>
<pre><code>mov ax,8    //寄存器，数据
mov ax,bx   //寄存器，寄存器
mov ax,[0]  //寄存器，内存单元
mov [0],ax  //内存单元，寄存器
mov ds,ax   //段寄存器，寄存器
</code></pre>
<p> 利用Debug验证后，下列指令也可成立：</p>
<pre><code>mov ax,dx   //寄存器，段寄存器
mov [0],cs  //内存单元，段寄存器
mov ds,[0]  //段寄存器，内存单元
</code></pre>
<p> add和sub指令同mov一样，都有两个操作对象，它们也可以有以下几种形式：</p>
<pre><code>add ax,8    //寄存器，数据
add ax,bx   //寄存器，寄存器
add ax,[0]  //寄存器，内存单元
add [0],ax  //内存单元，寄存器
sub ax,9    //寄存器，数据
sub sx,bx   //寄存器，寄存器
sub ax,[0]  //寄存器，内存单元
sub [0],ax  //内存单元，寄存器
</code></pre>
<p> <mark>但他们无法对段寄存器操作</mark></p>
<h2 id="35-数据段">3.5 数据段</h2>
<p> 对于8086机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为N(N&lt;=64KB)、地址连续、起始地址为16的倍数的内存单元当做专门存储数据的内存空间，从而定义了一个数据段。<br>
 比如讲 123B0H~123B9H 的内存单元定义为数据段。现在要累加这个数据段中的前3个单元的数据，代码如下。</p>
<pre><code>mov ax,123BH    
mov ds,ax       //将123BH送入ds中，作为数据段的段地址
mov al,0        //用al存放累加结果
add al,[0]      //将数据段第一个单元（偏移地址为0）中的数值加到al中
add al,[1]      //将数据段第二个单元（偏移地址为0）中的数值加到al中
add al,[2]      //将数据段第三个单元（偏移地址为0）中的数值加到al中
</code></pre>
<h2 id="36-桟">3.6 桟</h2>
<p> 桟是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。</p>
<table>
<thead>
<tr>
<th style="text-align:center">桟</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">...</td>
</tr>
<tr>
<td style="text-align:center">...</td>
</tr>
<tr>
<td style="text-align:center">四单个数据</td>
</tr>
<tr>
<td style="text-align:center">第二个数据</td>
</tr>
<tr>
<td style="text-align:center">第一个数据</td>
</tr>
</tbody>
</table>
<p> 入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入桟，需要出栈时，由最先被从桟中取出。桟的这种操作规则被称为：LIFO（Last In First Out）。</p>
<h2 id="37-cpu提供的桟机制">3.7 CPU提供的桟机制</h2>
<p> 8086CPU提供入栈和出栈指令，最基本的两个是 PUSH（入栈）和 POP（出栈）。</p>
<pre><code>push ax //将寄存器ax中的数据送入桟中
pop ax  //从栈顶取出数据送入ax
</code></pre>
<p> <mark>8086CPU的入栈和出栈操作都是以<strong>字</strong>为单位进行的</mark></p>
<p> 8086CPU中，有两个寄存器，段寄存器 SS 和寄存器 SP，栈顶的段地址存放在 SS 中，偏移地址存放在 SP 中。任意时刻， SS:SP 指向<strong>栈顶元素</strong>。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。</p>
<p> push ax的执行，由以下两步组成。</p>
<ol>
<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶。</li>
<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。</li>
</ol>
<p> 8086CPU对push指令的执行过程：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
<th>SS:SP位置</th>
<th>当前状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SS=1000</td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SP=000E</td>
</tr>
<tr>
<td>1000B</td>
<td></td>
<td></td>
<td>AX=2266</td>
</tr>
<tr>
<td>1000C</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000D</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000E</td>
<td>23</td>
<td>←SS:SP</td>
<td></td>
</tr>
<tr>
<td>1000F</td>
<td>01</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p> ↑栈中原本存在数据0123H，此时SS:SP指向1000EH。</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
<th>SS:SP位置</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SS=1000</td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SP=000C</td>
</tr>
<tr>
<td>1000B</td>
<td></td>
<td></td>
<td>AX=2266</td>
</tr>
<tr>
<td>1000C</td>
<td></td>
<td>←SS:SP</td>
<td></td>
</tr>
<tr>
<td>1000D</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000E</td>
<td>23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000F</td>
<td>01</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p> ↑CPU执行push，第一步：SP=SP-2，SS:SP指向1000CH。</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
<th>SS:SP位置</th>
<th>当前状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SS=1000</td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SP=000C</td>
</tr>
<tr>
<td>1000B</td>
<td></td>
<td></td>
<td>AX=2266</td>
</tr>
<tr>
<td>1000C</td>
<td>66</td>
<td>←SS:SP</td>
<td></td>
</tr>
<tr>
<td>1000D</td>
<td>22</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000E</td>
<td>23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000F</td>
<td>01</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p> ↑CPU执行push，第二步：将AX中的数据送入SS:SP指向的内存单元处。</p>
<p> pop ax 的执行过程：</p>
<ol>
<li>将SS:SP指向的内存单元处的数据送入ax中。</li>
<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>
</ol>
<p>注意：出栈后，原本SS:SP指向的单元内的内容依然存在，但是它已经不在栈中。当再次执行push等入栈指令后，会被新数据覆盖。</p>
<h2 id="38-栈顶超界的问题">3.8 栈顶超界的问题</h2>
<p> 8086CPU不保证我对栈的操作不会越界。也就是说，8086CPU只知道栈顶在何处（SS:SP），而不知道我们安排的栈空间有多大。这好像CPU只知道当前要执行的指令在哪里（CS:IP），而不知道要执行的指令有多少。从这两点我们可以看出8086CPU的工作机理，它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。<br>
 我们在编程时要自己操心栈顶超界的问题。</p>
<h2 id="39-push-pop指令">3.9 push、pop指令</h2>
<p> push和pop指令的格式可以是如下形式：</p>
<pre><code>push 寄存器     //将一个寄存器的数据入栈
pop 寄存器      //出栈，用一个寄存器接收出栈的数据
</code></pre>
<p> 当然也可以是如下形式：</p>
<pre><code>push 段寄存器   //将一个段寄存器的数据入栈
pop 段寄存器    //出栈，用一个段寄存器接收出栈的数据
</code></pre>
<p> push和pop也可以在内存单元和内存单元之间传送数据：</p>
<pre><code>push 内存单元   //将一个内存字单元处的字入栈（**注意：栈操作都是以字为单位的**）
pop 内存单元    //出栈，用一个内存字单元接收出栈的数据
</code></pre>
<p> 比如：</p>
<pre><code>mov ax,1000H    
mov ds,ax       //内存单元的段地址要放在DS中
push [0]        //将1000：0处的字压入栈中
pop [2]         //出栈，出栈的数据送入1000：2处
</code></pre>
<p> 栈为空的情况：<br>
将10000~1000F当做栈，初始状态为空</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">内容</th>
<th>SS:SP指向</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10000</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">...</td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">...</td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1000C</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1000D</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1000E</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1000F</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">10010</td>
<td style="text-align:center">(其他内容)</td>
<td>←SS:SP</td>
</tr>
</tbody>
</table>
<p> 执行push时，CPU的两步操作是：先改变SP，后向SS:SP处传送。<br>
 执行pop时，CPU的两步操作是：先读取SS:SP处的数据，后改变SP。</p>
<p> 栈顶的变化范围：0~FFFFH。</p>
<h2 id="310-栈段">3.10 栈段</h2>
<p> 我们可以将长度为N（N&lt;=64KB）的一组地址连续、起始地址为16的倍数的内存单元当做栈来使用。</p>
<p> 如果将10000H~1FFFFH这段空间当做栈段，初始状态栈是空的，此时SS=1000H，<strong>SP=0</strong>。（任意时刻，SS:SP指向栈顶元素，当栈为空时，也就不存在栈顶元素，所以SS:SP只能指向站的最底部单元下面的单元，该单元的地址为栈最底部的字单元的地址+2。栈最底部字单元的地址为1000:FFFE，所以栈空时，SP=0000H）</p>
<h3 id="实验2">实验2：</h3>
<p> 当用T执行mov ss，ax（任何修改SS的指令）的时候，它的下一条指令也会被紧接着执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[StringBuffer作为参数传递问题]]></title>
        <id>https://zy080080.github.io//post/SbZ2wCsCd</id>
        <link href="https://zy080080.github.io//post/SbZ2wCsCd">
        </link>
        <updated>2019-09-12T09:12:57.000Z</updated>
        <content type="html"><![CDATA[<pre><code>public class StringBufferTest {
    public static void main(String[] args) {
	    String s1 = &quot;hello&quot;;
		String s2 = &quot;world&quot;;
    	System.out.println(s1 + &quot;---&quot; + s2);// hello---world
	    change(s1, s2);
		System.out.println(s1 + &quot;---&quot; + s2);// hello---world 

    	StringBuffer sb1 = new StringBuffer(&quot;hello&quot;);
	    StringBuffer sb2 = new StringBuffer(&quot;world&quot;);
    	System.out.println(sb1 + &quot;---&quot; + sb2);// hello---world
		change(sb1, sb2);
		System.out.println(sb1 + &quot;---&quot; + sb2);// hello---worldworld
	}

	public static void change(StringBuffer sb1, StringBuffer sb2) {
		sb1 = sb2;//引用的东西变了而已，main中的sb1引用没变
		sb2.append(sb1);
	}

    public static void change(String s1, String s2) {
	    s1 = s2;
	    s2 = s1 + s2;
    }
}</code></pre>
]]></content>
    </entry>
</feed>